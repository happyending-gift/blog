---
title: date_base
author: chengp
---

## 并发数据库操作中的读取问题

在并发数据库操作中，可能会出现脏读、不可重复读和幻读等问题，这些问题都与事务的隔离级别有关。

### 脏读 (Dirty Read)

- **定义**：一个事务读取到了另一个事务未提交的数据。
- **影响**：如果未提交的事务最终被回滚，那么读取到的数据就是无效的，这可能导致错误的决策。

### 不可重复读 (Non-repeatable Read)

- **定义**：在一个事务中多次读取同一数据，如果在两次读取之间，其他事务对数据进行了修改，那么两次读取的数据可能不一致。
- **影响**：这可能导致事务在处理过程中得到不同的结果，影响数据的一致性。

### 幻读 (Phantom Read)

- **定义**：在一个事务中多次读取同一范围的数据，如果在两次读取之间，其他事务插入或删除了数据，那么两次读取的数据数量可能不一致。
- **影响**：这可能导致事务在处理过程中得到不一致的数据集，影响数据的完整性。

### 隔离级别

为了解决这些问题，数据库系统提供了不同的事务隔离级别：

1. **读未提交 (Read Uncommitted)**：最低的隔离级别，可能出现脏读、不可重复读和幻读。
2. **读已提交 (Read Committed)**：避免了脏读，但可能出现不可重复读和幻读。
3. **可重复读 (Repeatable Read)**：避免了脏读和不可重复读，但可能出现幻读。
4. **串行化 (Serializable)**：最高的隔离级别，避免了脏读、不可重复读和幻读，但性能开销较大。

## 聚簇索引
根据ID构建，且叶子节点保存所有行数据的索引，称之为聚簇索引，

他是存储MYSQL里面数据的基本结构，所以跟据ID数据查询时可以走聚簇索引，但要是不是ID就不能走聚簇索引。

## 非聚簇索引（二级索引）

叶子节点存储的是聚簇索引的字段，之后需要回表走聚簇索引，因为没有覆盖查询所需要的数据

## 索引覆盖（减少回表次数）

查询结果可以在二级索引获取，而无需访问表的实际数据，即无需回表查

## MyISAM 与 InnoDB 存储引擎的区别

在 MySQL 数据库中，InnoDB 和 MyISAM 是两种常用的存储引擎，它们在事务支持、锁定级别、外键支持、ACID 支持以及性能方面各有特点。

### 事务支持
- **MyISAM**：不支持事务处理。
- **InnoDB**：支持事务处理。

### 锁定级别
- **MyISAM**：使用表级锁定，即当一个线程读取一个表时，其他线程不能同时写入该表。
- **InnoDB**：支持行级锁定，允许更高的并发性。

### 外键支持
- **MyISAM**：不支持外键约束。
- **InnoDB**：支持外键约束，可以维护数据的引用完整性。

### ACID 支持
- **MyISAM**：不完全支持 ACID 特性。
- **InnoDB**：完全支持 ACID 特性，确保事务的原子性、一致性、隔离性和持久性。

### 性能
- **MyISAM**：在读操作多、写操作少的场景下性能较好，尤其是在处理大量数据时。
- **InnoDB**：在处理大量并发读写操作时性能较好。

- 如果需要支持事务、外键约束或者需要更好的数据完整性和一致性，应选择 **InnoDB**。
- 如果需要更好的读性能，且不需要事务处理，可以选择 **MyISAM**。

## 索引失效

索引列参与计算：如 WHERE age * 2 = 40，索引无法使用

对索引列进行函数操作：如 WHERE UPPER(name) = 'ZHANGSAN'，索引会失效

查询中使用了 OR 两边有范围查询：如 WHERE age = 10 OR age > 20，可能导致索引失效

LIKE操作：以 % 开头的 LIKE 查询，如 WHERE name LIKE '%zhangsan'，索引会失效

不等于比较：使用 != 或 <> 比较可能导致索引失效

IS NULL 或 IS NOT NULL：这些条件可能导致索引失效

字符串不加单引号：如 WHERE name = 2000，可能导致索引失效。隐式类型转换

使用 IN：当 IN 子句中的列表过大时，可能导致索引失效

使用 NOT IN：这可能导致索引失效，特别是当子查询返回大量数据时

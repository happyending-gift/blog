---
title: 多线程
---

## ThreadLocalMap的引用类型

::: tip answer
ThreadLocalMap 的 key 是弱引用，而 value 是强引用。
::: 

### 为什么 ThreadLocalMap 的键（Key）是弱引用（Weak Reference）？
  ThreadLocalMap 是线程的成员变量，只要线程还未结束，它就会一直被线程强引用。如果我们假设 ThreadLocalMap 中的 Entry 对象的键是对 ThreadLocal 对象的强引用，那么这个 Entry 将持有 ThreadLocal 对象和值对象的强引用。如果在其他地方没有对这个 ThreadLocal 对象的引用，并且在使用 ThreadLocalMap 的过程中没有正确地在用完后就调用 remove() 方法，那么这个 ThreadLocal 对象和所关联的值对象就会随着线程一直存在，这样可能会造成内存泄漏问题。 特别是在使用线程池的时候，核心线程会一直存在直到程序结束。如果这些线程中的 ThreadLocalMap 中的数据没有被及时清理，就会一直占用内存，而且在线程复用时可能会导致数据错乱的危险。

  如果 Entry 的键是对 ThreadLocal 对象的弱引用：弱引用意味着，如果没有其他引用对象的强引用关系，那么这个仅被弱引用的对象在下次垃圾回收（GC）时就会被回收掉，这样在一定程度上降低了内存泄漏的风险。但同时也引入了新的问题，即键虽然被回收了，但是值对象还在，我们无法获取，也无法删除，这样也会存在内存泄漏的风险。虽然 ThreadLocalMap 中在进行 set 和 get 操作时会进行启发式清理和探测式清理，清理一部分键为 null 的 Entry 对象，但是这只是一种后备选择，最重要的还是开发人员在编写代码时记得在使用完数据后及时调用 remove() 方法手动清理。

::: tip 内存泄漏
有些对象已经不再使用了，但是由于没有正确处理对象的引用关系，使得这个无用的对象还一直被 GC Root 直接或间接引用着，垃圾回收时就无法清理掉这些对象，如果这类对象存在很多，就会导致内存泄漏。
::: 

### 为什么 ThreadLocalMap的值（Value）是强引用？
  如果值是弱引用，那么在没有其他强引用指向这个值的情况下，值可能会在任何时候被垃圾回收器回收。这将导致 ThreadLocal 无法正确地存储和检索数据，因为它们可能会在不被期望的情况下突然消失。
    
  强引用保证数据完整性：使用强引用作为 ThreadLocalMap的值确保了只要ThreadLocal对象存在，其关联的数据值也会一直存在，直到显式地通过remove()方法或线程结束时清理。这样可以保证数据的完整性和一致性，避免因垃圾回收导致的潜在错误。


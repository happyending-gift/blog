---
title: 虚拟机
author: chengp
---

## 类加载过程

### 加载（Loading）
将class文件的二进制字节流所代表的静态存储结构转化为方法区运行时的数据结构。
### 连接（验证、准备、解析）
验证：确保 .class 文件中的字节流包含的信息符合当前虚拟机的要求

准备：为类中的静态字段分配内存，并设置默认的初始值（如 int 类型初始值是 0）。 被 final 修饰的 static 字段不会设置，因为 final 在编译的时候就分配了。

解析：解析阶段是虚拟机将常量池的符号引用直接替换为直接引用的过程。

### 初始化、使用、卸载
初始化阶段简单来说就是执行类的构造器方法，不是开发者写的，而是编译器自动生成的。

## 垃圾收集器

| 垃圾收集器                  | 类型     | 作用域          | 使用算法         | 特点         | 适用场景                             |
|---------------------------|--------|--------------|--------------|------------|----------------------------------|
| Serial                   | 串行回收 | 新生代         | 复制算法         | 响应速度优先   | 适用于单核 CPU 环境下的 Client 模式       |
| Serial Old               | 串行回收 | 老年代         | 标记-压缩算法     | 响应速度优先   | 适用于单核 CPU 环境下的 Client 模式       |
| ParNew                  | 并行回收 | 新生代         | 复制算法         | 响应速度优先   | 多核 CPU 环境中 Server 模式下与 CMS 配合使用 |
| Parallel Scavenge        | 并行回收 | 新生代         | 复制算法         | 吞吐量优先     | 适用于后台运算，而交互少的场景            |
| Parallel Old             | 并行回收 | 老年代         | 标记-压缩算法     | 吞吐量优先     | 适用于后台运算，而交互少的场景            |
| CMS(Concurrent Mark-Sweep) | 并发回收 | 老年代         | 标记-清除算法     | 响应速度优先   | 适用于 B/S 业务，也就是交互多的场景         |
| G1(Garbage-First)        | 并发, 并行回收 | 新生代 & 老年代(整堆收集器) | 复制算法 & 标记-压缩算法 | 响应速度优先   | 面向服务端的应用                       |

## 静态代理、动态代理
类编译时产生，静态 

类运行时产生，动态

静态代理：代理类与被代理类实现相同接口，相同方法，代理类需要有被代理类的成员变量，这样就可以在被代理对象时候做增强。

动态代理，允许我们运行时生成代理对象，实现方案时GDK给我们提供的proxy类，CG lab提供的api,被代理有接口实现就实现响应接口，没有就继承，



## 双亲委派
当我们进行类加载时，我们会先从appclassloader缓存查找，

若没有会向extclassloader、bootstrapclassloader的缓存查找，

如果还没有，他将向下在加载器对应路径查找

### 为什么使用双亲委派

- **避免类的重复加载**：确保一个类只被加载一次。
- **保证 Java 核心 API 的安全性**：防止核心 API 被随意篡改。
- **提供类加载的层次结构**：允许用户自定义类加载器以满足特定需求。


## 类加载时成员变量和静态成员变量的初始化时机

在 Java 中，类的加载和初始化涉及到成员变量和静态成员变量的初始化时机，它们之间存在一些关键的差异：

### 未使用 static 修饰的成员变量和成员对象

- 这些成员变量和对象是在 **类的的第一个实例被创建时** 进行初始化的。
- 这意味着它们与特定类的实例相关联，每个实例都会有自己的副本。

### 使用 static 修饰的成员变量

- 静态成员变量是在 **类加载阶段** 进行初始化的。
- 它们与类的实例化无关，属于类本身，而不是类的某个特定实例。
- 因此，静态成员变量在类第一次被加载到 JVM 时就初始化，并且只会初始化一次。

### 初始化时机的比较

- 由于 static 修饰的成员变量在类加载时就初始化，它们会比未使用 static 修饰的普通成员变量 **更早进行初始化**。
- 这种差异在设计类和方法时需要考虑，特别是涉及到类的静态上下文和单例模式等场景。

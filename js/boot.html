<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <link rel="icon" href="/favicon.ico"><title>springboot | 小陈文档</title><meta name="description" content="繁星似海 熠熠生辉">
    <link rel="preload" href="/blog/assets/style-Ci6kIX3i.css" as="style"><link rel="stylesheet" href="/blog/assets/style-Ci6kIX3i.css">
    <link rel="modulepreload" href="/blog/assets/app-BONF7y_X.js"><link rel="modulepreload" href="/blog/assets/boot.html-DpMlHLJZ.js">
    <link rel="prefetch" href="/blog/assets/index.html-EfKA1RoZ.js" as="script"><link rel="prefetch" href="/blog/assets/about.html-CQYM8tRF.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DURA6FUC.js" as="script"><link rel="prefetch" href="/blog/assets/about.html-9L-kIvKD.js" as="script"><link rel="prefetch" href="/blog/assets/JUC.html-C5Fa5YGZ.js" as="script"><link rel="prefetch" href="/blog/assets/JVM.html-SEiZA71H.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-4l70CpdY.js" as="script"><link rel="prefetch" href="/blog/assets/computer_network.html-DnHiLspb.js" as="script"><link rel="prefetch" href="/blog/assets/dataType.html-A_N77g4Z.js" as="script"><link rel="prefetch" href="/blog/assets/datebase.html-CDWMfVEa.js" as="script"><link rel="prefetch" href="/blog/assets/javabase.html-1rJ6KEum.js" as="script"><link rel="prefetch" href="/blog/assets/mq1.html--I5-kiVs.js" as="script"><link rel="prefetch" href="/blog/assets/operator.html-C-sasvhX.js" as="script"><link rel="prefetch" href="/blog/assets/python1.html-BOh_lXWa.js" as="script"><link rel="prefetch" href="/blog/assets/redis1.html-C4GJbvCX.js" as="script"><link rel="prefetch" href="/blog/assets/sentence.html-CmHGjapu.js" as="script"><link rel="prefetch" href="/blog/assets/tip.html-B_l_VMun.js" as="script"><link rel="prefetch" href="/blog/assets/var.html-BK_8CezP.js" as="script"><link rel="prefetch" href="/blog/assets/Base64.html-D3GvDXhf.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DfUyuhDP.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-FwICEOjE.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bvh_ObhO.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BVTJekSY.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CBAOPeHR.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-B7SJ0YvW.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-a0SPzfpD.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DZtiijfO.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DjF3qeZc.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BmofhC9Q.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CoG9M_aU.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-VO_UZyEX.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CdAHIz2H.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CsLi-dMA.js" as="script"><link rel="prefetch" href="/blog/assets/SearchResult-ckvGi3le.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/blog/"><img class="vp-site-logo" src="/blog/comet.png" alt="小陈文档"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">小陈文档</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/blog/" aria-label="主页"><!--[--><!--[--><!--]--><!--]-->主页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="语言"><span class="title">语言</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="语言"><span class="title">语言</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>编程</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://www.dotcpp.com/course/c/" aria-label="C" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->C<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link route-link-active auto-link" href="/blog/js/" aria-label="Js"><!--[--><!--[--><!--]--><!--]-->Js<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://ts.nodejs.cn" aria-label="Ts" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Ts<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://liaoxuefeng.com/books/java/introduction/index.html" aria-label="Java" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>标记</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" aria-label="HTML" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->HTML<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://markdown.com.cn/basic-syntax/" aria-label="Markdown" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Markdown<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" aria-label="CSS" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->CSS<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://www.sass.hk/" aria-label="Sass" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Sass<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://www.tailwindcss.cn/docs/installation" aria-label="Tailwindcss" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Tailwindcss<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="视频"><span class="title">视频</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="视频"><span class="title">视频</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="auto-link external-link" href="https://www.bilibili.com/video/BV1BuoqYDE4s/?spm_id_from=333.337.search-card.all.click&amp;vd_source=dfd89b4ec8cf2c897e32e3e3342bb775" aria-label="AImodel" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->AImodel<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="学习文档"><span class="title">学习文档</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="学习文档"><span class="title">学习文档</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="auto-link external-link" href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html" aria-label="Go" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Go<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="auto-link external-link" href="https://hd1611756908.github.io/2024/07/02/EasyExcel(%E7%94%9F%E6%88%90Excel%E6%8A%A5%E8%A1%A8)%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" aria-label="easyExcel" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->easyExcel<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/blog/article/" aria-label="归档"><!--[--><!--[--><!--]--><!--]-->归档<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/blog/about.html" aria-label="关于"><!--[--><!--[--><!--]--><!--]-->关于<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/blog/js/boot.html" aria-label="简体中文"><!--[--><!--[--><!--]--><!--]-->简体中文<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/en/" aria-label="English"><!--[--><!--[--><!--]--><!--]-->English<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!--[--><button type="button" class="slimsearch-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="slimsearch-placeholder">搜索</div><div class="slimsearch-key-hints"><kbd class="slimsearch-key">Ctrl</kbd><kbd class="slimsearch-key">K</kbd></div></button><!--]--></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/blog/" aria-label="主页"><!--[--><!--[--><!--]--><!--]-->主页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="语言"><span class="title">语言</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="语言"><span class="title">语言</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>编程</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://www.dotcpp.com/course/c/" aria-label="C" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->C<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link route-link-active auto-link" href="/blog/js/" aria-label="Js"><!--[--><!--[--><!--]--><!--]-->Js<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://ts.nodejs.cn" aria-label="Ts" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Ts<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://liaoxuefeng.com/books/java/introduction/index.html" aria-label="Java" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>标记</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" aria-label="HTML" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->HTML<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://markdown.com.cn/basic-syntax/" aria-label="Markdown" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Markdown<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" aria-label="CSS" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->CSS<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://www.sass.hk/" aria-label="Sass" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Sass<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://www.tailwindcss.cn/docs/installation" aria-label="Tailwindcss" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Tailwindcss<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="视频"><span class="title">视频</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="视频"><span class="title">视频</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="auto-link external-link" href="https://www.bilibili.com/video/BV1BuoqYDE4s/?spm_id_from=333.337.search-card.all.click&amp;vd_source=dfd89b4ec8cf2c897e32e3e3342bb775" aria-label="AImodel" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->AImodel<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="学习文档"><span class="title">学习文档</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="学习文档"><span class="title">学习文档</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="auto-link external-link" href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html" aria-label="Go" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Go<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="auto-link external-link" href="https://hd1611756908.github.io/2024/07/02/EasyExcel(%E7%94%9F%E6%88%90Excel%E6%8A%A5%E8%A1%A8)%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" aria-label="easyExcel" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->easyExcel<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/blog/article/" aria-label="归档"><!--[--><!--[--><!--]--><!--]-->归档<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/blog/about.html" aria-label="关于"><!--[--><!--[--><!--]--><!--]-->关于<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/blog/js/boot.html" aria-label="简体中文"><!--[--><!--[--><!--]--><!--]-->简体中文<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/blog/en/" aria-label="English"><!--[--><!--[--><!--]--><!--]-->English<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">目录 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/blog/js/JUC.html" aria-label="多线程"><!--[--><!--[--><!--]--><!--]-->多线程<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/blog/js/boot.html" aria-label="springboot"><!--[--><!--[--><!--]--><!--]-->springboot<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/blog/js/tip.html" aria-label="小提示"><!--[--><!--[--><!--]--><!--]-->小提示<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/blog/js/JVM.html" aria-label="虚拟机"><!--[--><!--[--><!--]--><!--]-->虚拟机<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/blog/js/javabase.html" aria-label="java基础"><!--[--><!--[--><!--]--><!--]-->java基础<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/blog/js/datebase.html" aria-label="date_base"><!--[--><!--[--><!--]--><!--]-->date_base<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/blog/js/mq1.html" aria-label="mq"><!--[--><!--[--><!--]--><!--]-->mq<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/blog/js/python1.html" aria-label="python"><!--[--><!--[--><!--]--><!--]-->python<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/blog/js/redis1.html" aria-label="redis"><!--[--><!--[--><!--]--><!--]-->redis<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h2 id="spring-ioc-容器构建" tabindex="-1"><a class="header-anchor" href="#spring-ioc-容器构建"><span>Spring IoC 容器构建</span></a></h2><ul><li><p>获取一个新的 bean 工厂：通常是 ApplicationContext</p></li><li><p>加载和解析 spring 的配置，解析 bean 对象，将解析到的 bean 封装成 BeanDefinition，并放到本地缓存中</p></li><li><p>实例化和调用 BeanFactoryPostProcessor (BeanDefinitionRegistryPostProcessor) 的扩展方法，这边是一个非常重要的扩展点</p></li><li><p>实例化 BeanPostProcessor，加载到 BeanFactory 中，但是这边还不触发，该扩展接口的方法在 bean 对象执行初始化方法前后被触发，这边是另一个重要扩展点</p></li><li><p>实例化所有剩余的 bean 实例（非懒加载），包括：创建 bean 实例、bean 实例属性填充、bean 实例的初始化</p></li><li><p>完成容器刷新，推送上下文刷新完毕事件（ContextRefreshedEvent）到监听器</p></li></ul><h2 id="spring-boot-与-spring-mvc-的区别" tabindex="-1"><a class="header-anchor" href="#spring-boot-与-spring-mvc-的区别"><span>Spring Boot 与 Spring MVC 的区别</span></a></h2><p>Spring Boot 和 Spring MVC 都是 Spring 家族中的重要成员，但它们的定位和用途有所不同。</p><h3 id="spring-boot" tabindex="-1"><a class="header-anchor" href="#spring-boot"><span>Spring Boot</span></a></h3><ul><li><strong>定义</strong>：Spring Boot 是基于 Spring 框架的快速开发框架。</li><li><strong>特点</strong>： <ul><li>提供了快速开发的便利性。</li><li>简化了 Spring 应用的初始搭建和开发过程。</li><li>内嵌了 Tomcat、Jetty 等服务器，无需部署 WAR 文件。</li><li>提供了生产就绪的特性，如健康检查、外部化配置等。</li></ul></li><li><strong>用途</strong>：适用于构建独立的、生产级别的 Spring 应用。</li></ul><h3 id="spring-mvc" tabindex="-1"><a class="header-anchor" href="#spring-mvc"><span>Spring MVC</span></a></h3><ul><li><strong>定义</strong>：Spring MVC 是 Spring 框架中的一个模块，专注于构建 Web 应用。</li><li><strong>特点</strong>： <ul><li>提供了模型-视图-控制器（MVC）架构的支持。</li><li>支持 RESTful Web 服务。</li><li>可以与 Spring 框架的其他模块无缝集成。</li></ul></li><li><strong>用途</strong>：适用于构建 Web 应用，特别是需要与 Spring 框架集成的应用。</li></ul><h3 id="spring-cloud" tabindex="-1"><a class="header-anchor" href="#spring-cloud"><span>Spring Cloud</span></a></h3><ul><li><strong>定义</strong>：Spring Cloud 是一个完整的微服务框架。</li><li><strong>特点</strong>： <ul><li>提供了微服务架构下的各种解决方案，如服务发现、配置管理、断路器、智能路由等。</li><li>依赖于 Spring Boot，利用 Spring Boot 的特性简化了微服务的开发。</li></ul></li><li><strong>用途</strong>：适用于构建和管理微服务架构。</li></ul><h3 id="spring-boot-与-spring-mvc-的关系" tabindex="-1"><a class="header-anchor" href="#spring-boot-与-spring-mvc-的关系"><span>Spring Boot 与 Spring MVC 的关系</span></a></h3><p>Spring Boot 提供了集成 Spring MVC 的能力。当开发 Web 应用时，Spring Boot 默认使用 Spring MVC 作为 Web 层的框架。这意味着在 Spring Boot 应用中开发 Web 功能，本质上就是在使用 Spring MVC。</p><h2 id="controller-与-restcontroller-的区别" tabindex="-1"><a class="header-anchor" href="#controller-与-restcontroller-的区别"><span>Controller 与 RestController 的区别</span></a></h2><p>在 Spring MVC 框架中，Controller 和 RestController 都用于处理 HTTP 请求，但它们在返回类型和用途上有所不同。</p><h3 id="restcontroller" tabindex="-1"><a class="header-anchor" href="#restcontroller"><span>RestController</span></a></h3><p>特点</p><ul><li>@RestController 是@Controller 和@ResponseBody的组合注解。</li><li>主要用于构建 RESTful Web 服务。</li></ul><p>返回类型</p><ul><li>默认返回 JSON 或 XML 格式的数据。</li><li>适用于需要直接返回数据而不是视图的 API 接口。</li></ul><h3 id="controller" tabindex="-1"><a class="header-anchor" href="#controller"><span>Controller</span></a></h3><p>特点</p><ul><li>@Controller用于定义一个控制器，处理 HTTP 请求并返回响应。</li><li>可以返回ModelAndView，即模型数据和视图的组合。</li></ul><p>返回类型</p><ul><li>可以返回视图（View），通常用于 Web 应用。</li><li>需要通过视图解析器将模型数据渲染到页面上。</li></ul><h3 id="responsebody" tabindex="-1"><a class="header-anchor" href="#responsebody"><span>@ResponseBody</span></a></h3><p>作用</p><p>-@ResponseBody注解用于将返回对象直接转换为 JSON 或 XML 格式，并写入 HTTP 响应体中。</p><ul><li>不经过视图解析器处理，直接返回数据。</li></ul><h2 id="spring-boot-自动配置类" tabindex="-1"><a class="header-anchor" href="#spring-boot-自动配置类"><span>Spring Boot 自动配置类</span></a></h2><p>Spring Boot 的自动配置机制是其核心特性之一，它简化了 Spring 应用的配置过程。以下是 Spring Boot 自动配置类的工作原理：</p><p>引入@EnableConfigurationProperties</p><p>通过@SpringBootConfiguration注解引入@EnableConfigurationProperties注解，它负责自动配置。</p><p>引入@Import</p><p>通过@EnableConfigurationProperties注解引入@Import注解。容器启动时，加载 IOC 容器会解析@Import注解。</p><p>Deferred Import Selector</p><p>@Import注解导入了一个 DeferredImportSelector，其目的是使自动配置类最后执行。</p><p>读取META-INF/spring.factories</p><p>Spring Boot 读取META-INF目录下的spring.factories文件，该文件中列出了所有自动配置类。</p><p>使用@Conditional 注解</p><p>最后，通过@Conditional注解排除无效配置类，确保只有符合条件的配置类被加载。</p><h3 id="工作流程总结" tabindex="-1"><a class="header-anchor" href="#工作流程总结"><span>工作流程总结</span></a></h3><ol><li><strong>启动应用</strong>：Spring Boot 应用启动。</li><li><strong>加载配置</strong>：读取 spring.factories 文件中的自动配置类。</li><li><strong>条件判断</strong>：使用 @Conditional 注解进行条件判断。</li><li><strong>执行配置</strong>：符合条件的配置类被执行，完成自动配置。</li></ol><h2 id="spring-注解概览" tabindex="-1"><a class="header-anchor" href="#spring-注解概览"><span>Spring 注解概览</span></a></h2><p>在 Spring 框架中，注解（Annotations）是实现依赖注入（Dependency Injection）和配置类的重要手段。以下是一些常用的注解及其说明：</p><h3 id="component-与-bean" tabindex="-1"><a class="header-anchor" href="#component-与-bean"><span>@Component 与 @Bean</span></a></h3><ul><li><p><strong>@Component</strong></p><ul><li>注解作用于类。</li><li>标识该类为一个 Spring 管理的组件（Bean）。</li></ul></li><li><p><strong>@Bean</strong></p><ul><li>注解作用于方法。</li><li>用于显式地声明一个 Bean，自定义性更强。</li><li>在某些情况下，只能通过@Bean注解注册 Bean。</li></ul></li></ul><h3 id="autowired-与-resource" tabindex="-1"><a class="header-anchor" href="#autowired-与-resource"><span>@Autowired 与 @Resource</span></a></h3><ul><li><p><strong>@Autowired</strong></p><ul><li>Spring 提供的注解。</li><li>默认的注入方式为 byType（根据类型进行匹配）。</li><li>可以通过@Qualifier注解来显式指定名称。</li><li>支持在构造函数、方法、字段和参数上使用。</li></ul></li><li><p><strong>@Resource</strong></p><ul><li>JDK 提供的注解。</li><li>默认注入方式为 byName（根据名称进行匹配）。</li><li>可以通过name属性来显式指定名称。</li><li>主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li></ul></li></ul><h2 id="bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#bean-的生命周期"><span>@Bean 的生命周期</span></a></h2><p>在 Spring 框架中，@Bean 注解用于声明一个由 Spring 容器管理的 Bean。以下是 Bean 的完整生命周期流程：</p><ol><li><strong>实例化（Instantiation）</strong></li></ol><ul><li>IOC 容器启动后，通过反射机制实例化 Bean。</li></ul><ol start="2"><li><strong>属性赋值（Populate properties）</strong></li></ol><ul><li>为 Bean 的属性赋值。</li></ul><ol start="3"><li><strong>Aware 接口检查</strong></li></ol><ul><li>检查实现了Aware接口的 Bean，并调用相应的方法，如setBeanFactory、setApplicationContext等。</li></ul><ol start="4"><li><strong>BeanPostProcessor 前置处理</strong></li></ol><ul><li>在初始化方法调用之前执行BeanPostProcessor接口的postProcessBeforeInitialization方法。</li></ul><ol start="5"><li><strong>InitializingBean 接口和 init-method</strong></li></ol><ul><li>检查实现了InitializingBean接口的 Bean，并调用其afterPropertiesSet方法。</li><li>检查定义了init-method的 Bean，并调用指定的初始化方法。</li></ul><ol start="6"><li><strong>BeanPostProcessor 后置处理</strong></li></ol><ul><li>在初始化方法调用之后执行BeanPostProcessor接口的postProcessAfterInitialization方法。</li></ul><ol start="7"><li><strong>使用（Usage）</strong></li></ol><ul><li>Bean 准备就绪，可以被应用程序使用了。</li></ul><ol start="8"><li><strong>销毁前处理（Destruction）</strong></li></ol><ul><li>当容器关闭时，如果 Bean 实现了DisposableBean 接口，将调用其destroy方法。</li><li>如果 Bean 定义了destroy-method，则调用该方法进行销毁。</li></ul><h2 id="bean-的线程安全性" tabindex="-1"><a class="header-anchor" href="#bean-的线程安全性"><span>Bean 的线程安全性</span></a></h2><p>在 Spring 框架中，Bean 的线程安全性是一个重要的考虑因素，特别是对于那些有状态的 Bean。</p><h3 id="有状态-bean" tabindex="-1"><a class="header-anchor" href="#有状态-bean"><span>有状态 Bean</span></a></h3><ul><li><strong>定义</strong>：有状态 Bean 是指包含可变成员变量的对象。</li><li><strong>问题</strong>：如果多个线程同时访问和修改这些可变的成员变量，就可能引发线程安全问题。</li></ul><h3 id="无状态-bean" tabindex="-1"><a class="header-anchor" href="#无状态-bean"><span>无状态 Bean</span></a></h3><ul><li><strong>定义</strong>：无状态 Bean 是指不包含可变成员变量的对象，或者其成员变量不会影响其业务逻辑的对象。</li><li><strong>优势</strong>：无状态 Bean 更容易保证线程安全，因为它们不会受到并发访问的影响。</li></ul><h2 id="spring-mvc-工作原理" tabindex="-1"><a class="header-anchor" href="#spring-mvc-工作原理"><span>Spring MVC 工作原理</span></a></h2><p>Spring MVC 是基于模型-视图-控制器（Model-View-Controller，简称 MVC）设计模式的 Web 框架。其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><ol><li><strong>客户端请求</strong></li></ol><ul><li>客户端（通常是浏览器）发送 HTTP 请求。</li></ul><ol start="2"><li><strong>DispatcherServlet 拦截</strong></li></ol><ul><li>DispatcherServlet拦截请求并作为前端控制器。</li></ul><ol start="3"><li><strong>HandlerMapping 匹配</strong></li></ol><ul><li>DispatcherServlet调用HandlerMapping。</li><li>HandlerMapping 根据 URL 匹配查找能处理请求的Handler（即Controller 控制器）。</li><li>将请求涉及到的拦截器和Handler一起封装。</li></ul><ol start="4"><li><strong>HandlerAdapter 执行</strong></li></ol><ul><li>DispatcherServlet 调用HandlerAdapter适配器执行Handler。</li></ul><ol start="5"><li><strong>返回 ModelAndView</strong></li></ol><ul><li>Handler完成对用户请求的处理后，返回一个ModelAndView对象给DispatcherServlet。</li><li>ModelAndView 包含了数据模型以及相应的视图信息。 <ul><li><strong>Model</strong>：返回的数据对象。</li><li><strong>View</strong>：逻辑上的视图。</li></ul></li></ul><ol start="6"><li><strong>ViewResolver 解析</strong></li></ol><ul><li>ViewResolver根据逻辑视图查找实际的视图。</li></ul><ol start="7"><li><strong>视图渲染</strong></li></ol><ul><li>DispatcherServlet把返回的Model传给视图（视图渲染）。</li></ul><ol start="8"><li><strong>返回响应</strong></li></ol><ul><li>将渲染后的视图返回给请求者（浏览器）。</li></ul><h2 id="统一异常处理" tabindex="-1"><a class="header-anchor" href="#统一异常处理"><span>统一异常处理</span></a></h2><p>在 Spring 应用中，统一异常处理是一种常见的需求，它有助于集中管理和响应应用程序中的各种异常。推荐使用注解的方式进行统一异常处理，具体会使用到 @ControllerAdvice 和 @ExceptionHandler 这两个注解。</p><h3 id="controlleradvice" tabindex="-1"><a class="header-anchor" href="#controlleradvice"><span>@ControllerAdvice</span></a></h3><ul><li>@ControllerAdvice 是一个类级别的注解，用于定义全局异常处理。</li><li>它可以指定所要应用的组件（如 @Controller、@RestController 等）。</li><li>通过定义一个或多个 @ControllerAdvice 类，可以集中处理特定类型的异常。</li></ul><h3 id="exceptionhandler" tabindex="-1"><a class="header-anchor" href="#exceptionhandler"><span>@ExceptionHandler</span></a></h3><ul><li>@ExceptionHandler 是一个方法级别的注解，用于处理特定的异常类型。</li><li>在 @ControllerAdvice 类中定义方法，并使用 @ExceptionHandler 注解指定该方法处理哪种异常。</li><li>可以针对不同的异常类型定义不同的处理逻辑。</li></ul><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token annotation punctuation">@ControllerAdvice</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleException</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;Global exception handler: &quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">INTERNAL_SERVER_ERROR</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">CustomException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleCustomException</span><span class="token punctuation">(</span><span class="token class-name">CustomException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">BAD_REQUEST</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="循环依赖及其解决方案" tabindex="-1"><a class="header-anchor" href="#循环依赖及其解决方案"><span>循环依赖及其解决方案</span></a></h2><p>在 Spring 框架中，循环依赖（Circular Dependency）指的是两个或多个 Bean 相互引用，导致无法完成初始化。为了解决这个问题，Spring 框架通过使用三级缓存机制来处理循环依赖。</p><h3 id="使用-lazy注解" tabindex="-1"><a class="header-anchor" href="#使用-lazy注解"><span>使用@Lazy注解</span></a></h3><ul><li>通过在构造函数注入上添加@Lazy注解，可以延迟 Bean 的初始化，从而避免循环依赖。</li></ul><h3 id="三级缓存机制" tabindex="-1"><a class="header-anchor" href="#三级缓存机制"><span>三级缓存机制</span></a></h3><ol><li><strong>第一级缓存（Singleton Cache）</strong></li></ol><ul><li>保存已经经过完整生命周期的 Bean 实例。</li></ul><ol start="2"><li><strong>第二级缓存（Early Singleton Cache）</strong></li></ol><ul><li>保存尚未经过完整生命周期的 Bean 实例。</li></ul><ol start="3"><li><strong>第三级缓存（Singleton Factories Cache）</strong></li></ol><ul><li>可以生成原始 Bean 对象或代理对象（如果 Bean 被 AOP 切面代理）。</li><li>仅对单例 Bean 生效。</li></ul><h3 id="处理循环依赖" tabindex="-1"><a class="header-anchor" href="#处理循环依赖"><span>处理循环依赖</span></a></h3><p>当发生循环依赖时：</p><ul><li>Spring 会从第三级缓存singletonFactories中获取ObjectFactory。</li><li>调用ObjectFactory的 getObject()方法来获取循环依赖对象的前期暴露对象（虽然还没有初始化完成，但可以获取到该对象在堆中的存储地址）。</li><li>将这个前期暴露对象放入第二级缓存中。</li></ul><p>通过这种方式，Spring 允许 Bean 在初始化过程中引用其他 Bean，从而解决了循环依赖的问题。</p><h2 id="spring-bean-作用域" tabindex="-1"><a class="header-anchor" href="#spring-bean-作用域"><span>Spring Bean 作用域</span></a></h2><p>在 Spring 框架中，Bean 的作用域（Scope）定义了 Bean 实例的生命周期和可见性。以下是几种常见的作用域：</p><h3 id="singleton" tabindex="-1"><a class="header-anchor" href="#singleton"><span>Singleton</span></a></h3><ul><li><strong>描述</strong>：唯一 Bean 实例。</li><li><strong>特点</strong>：在 Spring 应用的整个生命周期中，每个由 Spring 容器管理的 singleton 作用域的 Bean 只有一个实例。</li><li><strong>使用场景</strong>：当 Bean 可以被多个地方安全共享时。</li></ul><h3 id="prototype" tabindex="-1"><a class="header-anchor" href="#prototype"><span>Prototype</span></a></h3><ul><li><strong>描述</strong>：每次请求都会创建一个新的 Bean 实例。</li><li><strong>特点</strong>：每次请求该 Bean 时，Spring 容器都会创建一个新的实例。</li><li><strong>使用场景</strong>：当 Bean 的实例化需要特定的配置或状态时。</li></ul><h3 id="request" tabindex="-1"><a class="header-anchor" href="#request"><span>Request</span></a></h3><ul><li><strong>描述</strong>：每一次 HTTP 请求都会产生一个新的 Bean。</li><li><strong>特点</strong>：Bean 的生命周期与 HTTP 请求相同，请求结束后 Bean 被销毁。</li><li><strong>使用场景</strong>：处理每个 HTTP 请求所需的临时数据。</li></ul><h3 id="session" tabindex="-1"><a class="header-anchor" href="#session"><span>Session</span></a></h3><ul><li><strong>描述</strong>：每一个 HTTP Session 会产生一个新的 Bean。</li><li><strong>特点</strong>：Bean 的生命周期与 HTTP 会话相同，会话结束后 Bean 被销毁。</li><li><strong>使用场景</strong>：当需要在同一个会话中保持 Bean 状态时。</li></ul><h2 id="异常处理类" tabindex="-1"><a class="header-anchor" href="#异常处理类"><span>异常处理类</span></a></h2><p>在 Spring 框架中，异常处理类用于集中处理应用程序中的异常。</p><h3 id="controlleradvice-1" tabindex="-1"><a class="header-anchor" href="#controlleradvice-1"><span>@ControllerAdvice</span></a></h3><ul><li>@ControllerAdvice 注解用于定义全局异常处理类。</li><li>它可以捕获控制器层抛出的异常，并进行统一处理。</li></ul><h3 id="exceptionhandler-1" tabindex="-1"><a class="header-anchor" href="#exceptionhandler-1"><span>@ExceptionHandler</span></a></h3><ul><li>@ExceptionHandler 注解声明异常处理方法。</li><li>用于指定哪些异常将由特定的处理方法来处理。</li></ul><hr><h2 id="jpa注解" tabindex="-1"><a class="header-anchor" href="#jpa注解"><span>JPA注解</span></a></h2><p>JPA（Java Persistence API）提供了一系列的注解，用于实体映射和操作。</p><h3 id="entity" tabindex="-1"><a class="header-anchor" href="#entity"><span>@Entity</span></a></h3><ul><li>@Entity 注解声明一个类对应一个数据库实体。</li><li>被注解的类将映射到数据库中的一个表。</li></ul><h3 id="id" tabindex="-1"><a class="header-anchor" href="#id"><span>@Id</span></a></h3><ul><li>@Id 注解声明一个字段为主键。</li><li>使用 @Id 注解后，需要定义主键的生成策略。</li></ul><h3 id="generatedvalue" tabindex="-1"><a class="header-anchor" href="#generatedvalue"><span>@GeneratedValue</span></a></h3><ul><li>@GeneratedValue 注解指定主键生成策略。</li><li>例如，可以使用 @GeneratedValue(strategy = GenerationType.IDENTITY) 来指定主键的生成策略。</li></ul><h3 id="transient" tabindex="-1"><a class="header-anchor" href="#transient"><span>@Transient</span></a></h3><ul><li>@Transient 注解声明不需要与数据库映射的字段。</li><li>被注解的字段在保存时不会被保存到数据库中。</li></ul><hr><h2 id="事务管理" tabindex="-1"><a class="header-anchor" href="#事务管理"><span>事务管理</span></a></h2><h3 id="transactional" tabindex="-1"><a class="header-anchor" href="#transactional"><span>@Transactional</span></a></h3><ul><li>@Transactional 注解用于声明事务管理。</li><li>可以指定在遇到特定异常时进行回滚。</li><li>例如，@Transactional(rollbackFor = Exception.class) 让事务在遇到非运行时异常时也回滚。</li></ul><h2 id="spring事务传播行为" tabindex="-1"><a class="header-anchor" href="#spring事务传播行为"><span>spring事务传播行为</span></a></h2><p>事务传播是指一个事务调用另一个事务时，这个事务方法对另一个事务方法（调用者）的态度，a\b方法开启事务，a方法中调用了B方法，b方法传播到a方法的事务中，产生传播行为，这时我们需要对b方法进行处理。 他分7种：</p><p>第一种b在运行时需要事务，require,required-new，mandatory{抛异常}</p><p>第二种b在运行时不需要事务，supports,{有融入}not supported{有挂起}，never{有抛异常}</p><p>Nested支持嵌套事务，实现独立回滚</p><h2 id="dao接口工作原理" tabindex="-1"><a class="header-anchor" href="#dao接口工作原理"><span>DAO接口工作原理</span></a></h2><p>其工作原理时JDK动态代理， mybatis运行时会为dao接口生成动态代理对象，</p><p>对象会拦截方法，执行mappedstatement 的sql</p><h2 id="spring-框架中的设计模式" tabindex="-1"><a class="header-anchor" href="#spring-框架中的设计模式"><span>Spring 框架中的设计模式</span></a></h2><p>Spring 框架广泛地应用了多种设计模式，以下是一些主要的设计模式及其在 Spring 中的应用：</p><h3 id="工厂模式-factory-pattern" tabindex="-1"><a class="header-anchor" href="#工厂模式-factory-pattern"><span>工厂模式 (Factory Pattern)</span></a></h3><ul><li><strong>应用</strong>：BeanFactory 就用到了工厂模式。</li><li><strong>描述</strong>：工厂模式用于创建对象，而无需指定确切的类。Spring 通过 BeanFactory 提供了一个创建对象的接口。</li></ul><h3 id="单例模式-singleton-pattern" tabindex="-1"><a class="header-anchor" href="#单例模式-singleton-pattern"><span>单例模式 (Singleton Pattern)</span></a></h3><ul><li><strong>应用</strong>：Bean 的单例模式。</li><li><strong>描述</strong>：确保一个类只有一个实例，并提供一个全局访问点。Spring 中的 Bean 默认是单例的。</li></ul><h3 id="代理模式-proxy-pattern" tabindex="-1"><a class="header-anchor" href="#代理模式-proxy-pattern"><span>代理模式 (Proxy Pattern)</span></a></h3><ul><li><strong>应用</strong>：AOP 用到 JDK 的代理模式。</li><li><strong>描述</strong>：代理模式为其他对象提供一个代理以控制对这个对象的访问。Spring AOP（面向切面编程）功能就是基于代理模式实现的。</li></ul><h3 id="模板模式-template-pattern" tabindex="-1"><a class="header-anchor" href="#模板模式-template-pattern"><span>模板模式 (Template Pattern)</span></a></h3><ul><li><strong>应用</strong>：JDBC 模板。</li><li><strong>描述</strong>：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Spring 的 JdbcTemplate 就是模板模式的体现，它定义了数据库操作的通用步骤。</li></ul><h3 id="观察者模式-observer-pattern" tabindex="-1"><a class="header-anchor" href="#观察者模式-observer-pattern"><span>观察者模式 (Observer Pattern)</span></a></h3><ul><li><strong>应用</strong>：Spring 监听器的实现。</li><li><strong>描述</strong>：定义对象间的一种一对多的依赖关系，当一个对象改变状态时，所有依赖于它的对象都得到通知并被自动更新。Spring 事件监听器就是观察者模式的应用。</li></ul><h2 id="spring-boot-简介" tabindex="-1"><a class="header-anchor" href="#spring-boot-简介"><span>Spring Boot 简介</span></a></h2><p>Spring Boot 是一个基于 Spring 框架的快速开发框架，它简化了基于 Spring 的应用开发，提供了快速启动和部署 Spring 应用的能力。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ol><li><strong>自动依赖管理</strong>：</li></ol><ul><li>spring-boot-starter-web 会自动依赖其他组件，减少 Maven 配置。</li></ul><ol start="2"><li><strong>解决 Maven 依赖冲突</strong>：</li></ol><ul><li>Spring Boot 通过管理依赖版本来帮助解决 Maven 依赖冲突。</li></ul><ol start="3"><li><strong>内置服务器</strong>：</li></ol><ul><li>内置 Tomcat、Jetty、Undertow 等服务器，不需要打成 WAR 包，只需要打成可执行的 JAR 包就可以执行，所有依赖包都在一个 JAR 包中。</li></ul><ol start="4"><li><strong>自动装配 Bean</strong>：</li></ol><ul><li>Spring Boot 会根据当前类路径下的类自动装配 Bean，例如添加 spring-boot-starter-web 就能拥有 Web 功能。</li></ul><ol start="5"><li><strong>无 XML 配置</strong>：</li></ol><ul><li>配置过程无需 XML 文件就能完成所有配置工作，通过注解和 application.properties 或 application.yml 文件进行配置。</li></ul><div class="hint-container tip"><p class="hint-container-title">配置文件类型</p><p>properties优先加载级大于yml。</p></div><h2 id="spring-boot-核心注解" tabindex="-1"><a class="header-anchor" href="#spring-boot-核心注解"><span>Spring Boot 核心注解</span></a></h2><p>Spring Boot 提供了一系列注解来简化 Spring 应用的开发，以下是几个核心注解：</p><h3 id="springbootapplication" tabindex="-1"><a class="header-anchor" href="#springbootapplication"><span>@SpringBootApplication</span></a></h3><ul><li>组合注解，包含了 @SpringBootConfiguration、@EnableAutoConfiguration 和 @ComponentScan。</li><li>表明这是一个 Spring Boot 应用的启动类。</li></ul><h3 id="springbootconfiguration" tabindex="-1"><a class="header-anchor" href="#springbootconfiguration"><span>@SpringBootConfiguration</span></a></h3><ul><li>标识这是一个 Spring Boot 配置类。</li></ul><h3 id="enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#enableautoconfiguration"><span>@EnableAutoConfiguration</span></a></h3><ul><li>像容器中导入一个 selector，扫描 classpath 下的自动配置类，将这些自动加载为配置类。</li></ul><h3 id="componentscan" tabindex="-1"><a class="header-anchor" href="#componentscan"><span>@ComponentScan</span></a></h3><ul><li>标识扫描路径，默认扫描的是启动类所在的当前目录。</li><li>用于扫描并注册 Spring 组件，如 @Component、@Service、@Repository 和 @Controller 等。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>可以实现applicationrunner、commandlinerunner接口的runner方法实现，</p><p>可以用来进行一些定时任务（？），当然启动类也可以，在main方法中书写执行代码</p></div><h2 id="spring-设计模式" tabindex="-1"><a class="header-anchor" href="#spring-设计模式"><span>Spring 设计模式</span></a></h2><p>Spring 框架中广泛使用了多种设计模式，以下是一些核心的设计模式及其应用：</p><h3 id="控制反转-ioc-模式" tabindex="-1"><a class="header-anchor" href="#控制反转-ioc-模式"><span>控制反转 (IoC) 模式</span></a></h3><ul><li><strong>描述</strong>：将对象的创建交给 Spring 管理，实现了依赖的注入 (DI)。</li><li><strong>应用</strong>：通过 @Autowired 注解注解实现 Bean 之间的依赖注入。</li></ul><h3 id="工厂模式" tabindex="-1"><a class="header-anchor" href="#工厂模式"><span>工厂模式</span></a></h3><ul><li><strong>描述</strong>：ApplicationContext 即 Spring 容器，充当工厂类，负责创建 Bean 实例。</li><li><strong>应用</strong>：通过配置文件或注解定义 Bean 的创建逻辑。</li></ul><h3 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式"><span>单例模式</span></a></h3><ul><li><strong>描述</strong>：ApplicationContext 是一个单例 Bean，而每个 Bean 默认也是单例的。</li><li><strong>应用</strong>：确保 Bean 在整个应用程序中只有一个实例。</li></ul><h3 id="模板方法模式" tabindex="-1"><a class="header-anchor" href="#模板方法模式"><span>模板方法模式</span></a></h3><ul><li><strong>描述</strong>：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。</li><li><strong>应用</strong>：RedisTemplate 提供了一套统一的操作 Redis 的方法。</li></ul><h3 id="观察者模式" tabindex="-1"><a class="header-anchor" href="#观察者模式"><span>观察者模式</span></a></h3><ul><li><strong>描述</strong>：定义对象间的一种一对多的依赖关系，当一个对象改变状态时，所有依赖于它的对象都得到通知并被自动更新。</li><li><strong>应用</strong>：基于事件驱动的编程方式，如 ApplicationEvent、ApplicationListener。</li></ul><h3 id="策略模式" tabindex="-1"><a class="header-anchor" href="#策略模式"><span>策略模式</span></a></h3><ul><li><strong>描述</strong>：使用面向接口的编程思想定义策略层。</li><li><strong>应用</strong>：如 AuthenticationManager 策略接口等。</li></ul><h3 id="代理模式" tabindex="-1"><a class="header-anchor" href="#代理模式"><span>代理模式</span></a></h3><ul><li><strong>描述</strong>：为其他对象提供一个代理以控制对这个对象的访问。</li><li><strong>应用</strong>：AOP（面向切面编程）使用动态代理方式。</li></ul><h2 id="适配器模式" tabindex="-1"><a class="header-anchor" href="#适配器模式"><span>适配器模式</span></a></h2><ul><li><strong>描述</strong>：允许接口不兼容的类可以一起工作。</li><li><strong>应用</strong>：如 AdvisorAdapter 等，可以让任意类匹配某接口。</li></ul><h2 id="spring-mvc-请求处理流程" tabindex="-1"><a class="header-anchor" href="#spring-mvc-请求处理流程"><span>Spring MVC 请求处理流程</span></a></h2><p>Spring MVC 框架处理客户端请求的流程如下：</p><ol><li><strong>发送请求</strong>：</li></ol><ul><li>客户端（通常是浏览器）发送一个 HTTP 请求到服务器。</li></ul><ol start="2"><li><strong>请求处理</strong>：</li></ol><ul><li>请求被 Spring 的 <code>DispatcherServlet</code> 捕获，它是 Spring MVC 的前端控制器。</li></ul><ol start="3"><li><strong>请求映射</strong>：</li></ol><ul><li><code>DispatcherServlet</code> 使用 <code>HandlerMapping</code> 来确定请求应该由哪个控制器（<code>Controller</code>）处理。</li></ul><ol start="4"><li><strong>调用控制器</strong>：</li></ol><ul><li><code>DispatcherServlet</code> 调用匹配的控制器方法。</li></ul><ol start="5"><li><strong>业务逻辑</strong>：</li></ol><ul><li>控制器执行业务逻辑，可能包括调用服务层和数据访问层。</li></ul><ol start="6"><li><strong>返回视图</strong>：</li></ol><ul><li>控制器返回一个视图名称，通常通过 <code>ModelAndView</code> 对象。</li></ul><ol start="7"><li><strong>视图解析</strong>：</li></ol><ul><li><code>DispatcherServlet</code> 使用 <code>ViewResolver</code> 来解析视图名称，并找到实际的视图模板。</li></ul><ol start="8"><li><strong>渲染响应</strong>：</li></ol><ul><li>视图模板（如 JSP、Thymeleaf 等）被渲染成 HTML 内容。</li></ul><ol start="9"><li><strong>返回客户端</strong>：</li></ol><ul><li>最终的响应（包括 HTML 内容）被发送回客户端。</li></ul></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最近更新：: </span><time class="meta-item-info" datetime="2025-05-27T07:37:49.000Z" data-allow-mismatch>2025/5/27 07:37</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1787536379@qq.com">“root”</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/blog/js/JUC.html" aria-label="多线程"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span class="external-link">多线程</span></div><!--]--></a><a class="route-link auto-link next" href="/blog/js/tip.html" aria-label="小提示"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span class="external-link">小提示</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/blog/assets/app-BONF7y_X.js" defer></script>
  </body>
</html>

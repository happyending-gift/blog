import{_ as l,c as e,a,o as i}from"./app-Dq6GG4J-.js";const s={};function t(r,n){return i(),e("div",null,n[0]||(n[0]=[a(`<h2 id="spring-ioc-容器构建" tabindex="-1"><a class="header-anchor" href="#spring-ioc-容器构建"><span>Spring IoC 容器构建</span></a></h2><ul><li><p>获取一个新的 bean 工厂：通常是 ApplicationContext</p></li><li><p>加载和解析 spring 的配置，解析 bean 对象，将解析到的 bean 封装成 BeanDefinition，并放到本地缓存中</p></li><li><p>实例化和调用 BeanFactoryPostProcessor (BeanDefinitionRegistryPostProcessor) 的扩展方法，这边是一个非常重要的扩展点</p></li><li><p>实例化 BeanPostProcessor，加载到 BeanFactory 中，但是这边还不触发，该扩展接口的方法在 bean 对象执行初始化方法前后被触发，这边是另一个重要扩展点</p></li><li><p>实例化所有剩余的 bean 实例（非懒加载），包括：创建 bean 实例、bean 实例属性填充、bean 实例的初始化</p></li><li><p>完成容器刷新，推送上下文刷新完毕事件（ContextRefreshedEvent）到监听器</p></li></ul><h2 id="spring-boot-与-spring-mvc-的区别" tabindex="-1"><a class="header-anchor" href="#spring-boot-与-spring-mvc-的区别"><span>Spring Boot 与 Spring MVC 的区别</span></a></h2><p>Spring Boot 和 Spring MVC 都是 Spring 家族中的重要成员，但它们的定位和用途有所不同。</p><h3 id="spring-boot" tabindex="-1"><a class="header-anchor" href="#spring-boot"><span>Spring Boot</span></a></h3><ul><li><strong>定义</strong>：Spring Boot 是基于 Spring 框架的快速开发框架。</li><li><strong>特点</strong>： <ul><li>提供了快速开发的便利性。</li><li>简化了 Spring 应用的初始搭建和开发过程。</li><li>内嵌了 Tomcat、Jetty 等服务器，无需部署 WAR 文件。</li><li>提供了生产就绪的特性，如健康检查、外部化配置等。</li></ul></li><li><strong>用途</strong>：适用于构建独立的、生产级别的 Spring 应用。</li></ul><h3 id="spring-mvc" tabindex="-1"><a class="header-anchor" href="#spring-mvc"><span>Spring MVC</span></a></h3><ul><li><strong>定义</strong>：Spring MVC 是 Spring 框架中的一个模块，专注于构建 Web 应用。</li><li><strong>特点</strong>： <ul><li>提供了模型-视图-控制器（MVC）架构的支持。</li><li>支持 RESTful Web 服务。</li><li>可以与 Spring 框架的其他模块无缝集成。</li></ul></li><li><strong>用途</strong>：适用于构建 Web 应用，特别是需要与 Spring 框架集成的应用。</li></ul><h3 id="spring-cloud" tabindex="-1"><a class="header-anchor" href="#spring-cloud"><span>Spring Cloud</span></a></h3><ul><li><strong>定义</strong>：Spring Cloud 是一个完整的微服务框架。</li><li><strong>特点</strong>： <ul><li>提供了微服务架构下的各种解决方案，如服务发现、配置管理、断路器、智能路由等。</li><li>依赖于 Spring Boot，利用 Spring Boot 的特性简化了微服务的开发。</li></ul></li><li><strong>用途</strong>：适用于构建和管理微服务架构。</li></ul><h3 id="spring-boot-与-spring-mvc-的关系" tabindex="-1"><a class="header-anchor" href="#spring-boot-与-spring-mvc-的关系"><span>Spring Boot 与 Spring MVC 的关系</span></a></h3><p>Spring Boot 提供了集成 Spring MVC 的能力。当开发 Web 应用时，Spring Boot 默认使用 Spring MVC 作为 Web 层的框架。这意味着在 Spring Boot 应用中开发 Web 功能，本质上就是在使用 Spring MVC。</p><h2 id="controller-与-restcontroller-的区别" tabindex="-1"><a class="header-anchor" href="#controller-与-restcontroller-的区别"><span>Controller 与 RestController 的区别</span></a></h2><p>在 Spring MVC 框架中，Controller 和 RestController 都用于处理 HTTP 请求，但它们在返回类型和用途上有所不同。</p><h3 id="restcontroller" tabindex="-1"><a class="header-anchor" href="#restcontroller"><span>RestController</span></a></h3><p>特点</p><ul><li>@RestController 是@Controller 和@ResponseBody的组合注解。</li><li>主要用于构建 RESTful Web 服务。</li></ul><p>返回类型</p><ul><li>默认返回 JSON 或 XML 格式的数据。</li><li>适用于需要直接返回数据而不是视图的 API 接口。</li></ul><h3 id="controller" tabindex="-1"><a class="header-anchor" href="#controller"><span>Controller</span></a></h3><p>特点</p><ul><li>@Controller用于定义一个控制器，处理 HTTP 请求并返回响应。</li><li>可以返回ModelAndView，即模型数据和视图的组合。</li></ul><p>返回类型</p><ul><li>可以返回视图（View），通常用于 Web 应用。</li><li>需要通过视图解析器将模型数据渲染到页面上。</li></ul><h3 id="responsebody" tabindex="-1"><a class="header-anchor" href="#responsebody"><span>@ResponseBody</span></a></h3><p>作用</p><p>-@ResponseBody注解用于将返回对象直接转换为 JSON 或 XML 格式，并写入 HTTP 响应体中。</p><ul><li>不经过视图解析器处理，直接返回数据。</li></ul><h2 id="spring-boot-自动配置类" tabindex="-1"><a class="header-anchor" href="#spring-boot-自动配置类"><span>Spring Boot 自动配置类</span></a></h2><p>Spring Boot 的自动配置机制是其核心特性之一，它简化了 Spring 应用的配置过程。以下是 Spring Boot 自动配置类的工作原理：</p><p>引入@EnableConfigurationProperties</p><p>通过@SpringBootConfiguration注解引入@EnableConfigurationProperties注解，它负责自动配置。</p><p>引入@Import</p><p>通过@EnableConfigurationProperties注解引入@Import注解。容器启动时，加载 IOC 容器会解析@Import注解。</p><p>Deferred Import Selector</p><p>@Import注解导入了一个 DeferredImportSelector，其目的是使自动配置类最后执行。</p><p>读取META-INF/spring.factories</p><p>Spring Boot 读取META-INF目录下的spring.factories文件，该文件中列出了所有自动配置类。</p><p>使用@Conditional 注解</p><p>最后，通过@Conditional注解排除无效配置类，确保只有符合条件的配置类被加载。</p><h3 id="工作流程总结" tabindex="-1"><a class="header-anchor" href="#工作流程总结"><span>工作流程总结</span></a></h3><ol><li><strong>启动应用</strong>：Spring Boot 应用启动。</li><li><strong>加载配置</strong>：读取 spring.factories 文件中的自动配置类。</li><li><strong>条件判断</strong>：使用 @Conditional 注解进行条件判断。</li><li><strong>执行配置</strong>：符合条件的配置类被执行，完成自动配置。</li></ol><h2 id="spring-注解概览" tabindex="-1"><a class="header-anchor" href="#spring-注解概览"><span>Spring 注解概览</span></a></h2><p>在 Spring 框架中，注解（Annotations）是实现依赖注入（Dependency Injection）和配置类的重要手段。以下是一些常用的注解及其说明：</p><h3 id="component-与-bean" tabindex="-1"><a class="header-anchor" href="#component-与-bean"><span>@Component 与 @Bean</span></a></h3><ul><li><p><strong>@Component</strong></p><ul><li>注解作用于类。</li><li>标识该类为一个 Spring 管理的组件（Bean）。</li></ul></li><li><p><strong>@Bean</strong></p><ul><li>注解作用于方法。</li><li>用于显式地声明一个 Bean，自定义性更强。</li><li>在某些情况下，只能通过@Bean注解注册 Bean。</li></ul></li></ul><h3 id="autowired-与-resource" tabindex="-1"><a class="header-anchor" href="#autowired-与-resource"><span>@Autowired 与 @Resource</span></a></h3><ul><li><p><strong>@Autowired</strong></p><ul><li>Spring 提供的注解。</li><li>默认的注入方式为 byType（根据类型进行匹配）。</li><li>可以通过@Qualifier注解来显式指定名称。</li><li>支持在构造函数、方法、字段和参数上使用。</li></ul></li><li><p><strong>@Resource</strong></p><ul><li>JDK 提供的注解。</li><li>默认注入方式为 byName（根据名称进行匹配）。</li><li>可以通过name属性来显式指定名称。</li><li>主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li></ul></li></ul><h2 id="bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#bean-的生命周期"><span>@Bean 的生命周期</span></a></h2><p>在 Spring 框架中，@Bean 注解用于声明一个由 Spring 容器管理的 Bean。以下是 Bean 的完整生命周期流程：</p><ol><li><strong>实例化（Instantiation）</strong></li></ol><ul><li>IOC 容器启动后，通过反射机制实例化 Bean。</li></ul><ol start="2"><li><strong>属性赋值（Populate properties）</strong></li></ol><ul><li>为 Bean 的属性赋值。</li></ul><ol start="3"><li><strong>Aware 接口检查</strong></li></ol><ul><li>检查实现了Aware接口的 Bean，并调用相应的方法，如setBeanFactory、setApplicationContext等。</li></ul><ol start="4"><li><strong>BeanPostProcessor 前置处理</strong></li></ol><ul><li>在初始化方法调用之前执行BeanPostProcessor接口的postProcessBeforeInitialization方法。</li></ul><ol start="5"><li><strong>InitializingBean 接口和 init-method</strong></li></ol><ul><li>检查实现了InitializingBean接口的 Bean，并调用其afterPropertiesSet方法。</li><li>检查定义了init-method的 Bean，并调用指定的初始化方法。</li></ul><ol start="6"><li><strong>BeanPostProcessor 后置处理</strong></li></ol><ul><li>在初始化方法调用之后执行BeanPostProcessor接口的postProcessAfterInitialization方法。</li></ul><ol start="7"><li><strong>使用（Usage）</strong></li></ol><ul><li>Bean 准备就绪，可以被应用程序使用了。</li></ul><ol start="8"><li><strong>销毁前处理（Destruction）</strong></li></ol><ul><li>当容器关闭时，如果 Bean 实现了DisposableBean 接口，将调用其destroy方法。</li><li>如果 Bean 定义了destroy-method，则调用该方法进行销毁。</li></ul><h2 id="bean-的线程安全性" tabindex="-1"><a class="header-anchor" href="#bean-的线程安全性"><span>Bean 的线程安全性</span></a></h2><p>在 Spring 框架中，Bean 的线程安全性是一个重要的考虑因素，特别是对于那些有状态的 Bean。</p><h3 id="有状态-bean" tabindex="-1"><a class="header-anchor" href="#有状态-bean"><span>有状态 Bean</span></a></h3><ul><li><strong>定义</strong>：有状态 Bean 是指包含可变成员变量的对象。</li><li><strong>问题</strong>：如果多个线程同时访问和修改这些可变的成员变量，就可能引发线程安全问题。</li></ul><h3 id="无状态-bean" tabindex="-1"><a class="header-anchor" href="#无状态-bean"><span>无状态 Bean</span></a></h3><ul><li><strong>定义</strong>：无状态 Bean 是指不包含可变成员变量的对象，或者其成员变量不会影响其业务逻辑的对象。</li><li><strong>优势</strong>：无状态 Bean 更容易保证线程安全，因为它们不会受到并发访问的影响。</li></ul><h2 id="spring-mvc-工作原理" tabindex="-1"><a class="header-anchor" href="#spring-mvc-工作原理"><span>Spring MVC 工作原理</span></a></h2><p>Spring MVC 是基于模型-视图-控制器（Model-View-Controller，简称 MVC）设计模式的 Web 框架。其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><ol><li><strong>客户端请求</strong></li></ol><ul><li>客户端（通常是浏览器）发送 HTTP 请求。</li></ul><ol start="2"><li><strong>DispatcherServlet 拦截</strong></li></ol><ul><li>DispatcherServlet拦截请求并作为前端控制器。</li></ul><ol start="3"><li><strong>HandlerMapping 匹配</strong></li></ol><ul><li>DispatcherServlet调用HandlerMapping。</li><li>HandlerMapping 根据 URL 匹配查找能处理请求的Handler（即Controller 控制器）。</li><li>将请求涉及到的拦截器和Handler一起封装。</li></ul><ol start="4"><li><strong>HandlerAdapter 执行</strong></li></ol><ul><li>DispatcherServlet 调用HandlerAdapter适配器执行Handler。</li></ul><ol start="5"><li><strong>返回 ModelAndView</strong></li></ol><ul><li>Handler完成对用户请求的处理后，返回一个ModelAndView对象给DispatcherServlet。</li><li>ModelAndView 包含了数据模型以及相应的视图信息。 <ul><li><strong>Model</strong>：返回的数据对象。</li><li><strong>View</strong>：逻辑上的视图。</li></ul></li></ul><ol start="6"><li><strong>ViewResolver 解析</strong></li></ol><ul><li>ViewResolver根据逻辑视图查找实际的视图。</li></ul><ol start="7"><li><strong>视图渲染</strong></li></ol><ul><li>DispatcherServlet把返回的Model传给视图（视图渲染）。</li></ul><ol start="8"><li><strong>返回响应</strong></li></ol><ul><li>将渲染后的视图返回给请求者（浏览器）。</li></ul><h2 id="统一异常处理" tabindex="-1"><a class="header-anchor" href="#统一异常处理"><span>统一异常处理</span></a></h2><p>在 Spring 应用中，统一异常处理是一种常见的需求，它有助于集中管理和响应应用程序中的各种异常。推荐使用注解的方式进行统一异常处理，具体会使用到 @ControllerAdvice 和 @ExceptionHandler 这两个注解。</p><h3 id="controlleradvice" tabindex="-1"><a class="header-anchor" href="#controlleradvice"><span>@ControllerAdvice</span></a></h3><ul><li>@ControllerAdvice 是一个类级别的注解，用于定义全局异常处理。</li><li>它可以指定所要应用的组件（如 @Controller、@RestController 等）。</li><li>通过定义一个或多个 @ControllerAdvice 类，可以集中处理特定类型的异常。</li></ul><h3 id="exceptionhandler" tabindex="-1"><a class="header-anchor" href="#exceptionhandler"><span>@ExceptionHandler</span></a></h3><ul><li>@ExceptionHandler 是一个方法级别的注解，用于处理特定的异常类型。</li><li>在 @ControllerAdvice 类中定义方法，并使用 @ExceptionHandler 注解指定该方法处理哪种异常。</li><li>可以针对不同的异常类型定义不同的处理逻辑。</li></ul><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token annotation punctuation">@ControllerAdvice</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleException</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;Global exception handler: &quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">INTERNAL_SERVER_ERROR</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">CustomException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleCustomException</span><span class="token punctuation">(</span><span class="token class-name">CustomException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">BAD_REQUEST</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="循环依赖及其解决方案" tabindex="-1"><a class="header-anchor" href="#循环依赖及其解决方案"><span>循环依赖及其解决方案</span></a></h2><p>在 Spring 框架中，循环依赖（Circular Dependency）指的是两个或多个 Bean 相互引用，导致无法完成初始化。为了解决这个问题，Spring 框架通过使用三级缓存机制来处理循环依赖。</p><h3 id="使用-lazy注解" tabindex="-1"><a class="header-anchor" href="#使用-lazy注解"><span>使用@Lazy注解</span></a></h3><ul><li>通过在构造函数注入上添加@Lazy注解，可以延迟 Bean 的初始化，从而避免循环依赖。</li></ul><h3 id="三级缓存机制" tabindex="-1"><a class="header-anchor" href="#三级缓存机制"><span>三级缓存机制</span></a></h3><ol><li><strong>第一级缓存（Singleton Cache）</strong></li></ol><ul><li>保存已经经过完整生命周期的 Bean 实例。</li></ul><ol start="2"><li><strong>第二级缓存（Early Singleton Cache）</strong></li></ol><ul><li>保存尚未经过完整生命周期的 Bean 实例。</li></ul><ol start="3"><li><strong>第三级缓存（Singleton Factories Cache）</strong></li></ol><ul><li>可以生成原始 Bean 对象或代理对象（如果 Bean 被 AOP 切面代理）。</li><li>仅对单例 Bean 生效。</li></ul><h3 id="处理循环依赖" tabindex="-1"><a class="header-anchor" href="#处理循环依赖"><span>处理循环依赖</span></a></h3><p>当发生循环依赖时：</p><ul><li>Spring 会从第三级缓存singletonFactories中获取ObjectFactory。</li><li>调用ObjectFactory的 getObject()方法来获取循环依赖对象的前期暴露对象（虽然还没有初始化完成，但可以获取到该对象在堆中的存储地址）。</li><li>将这个前期暴露对象放入第二级缓存中。</li></ul><p>通过这种方式，Spring 允许 Bean 在初始化过程中引用其他 Bean，从而解决了循环依赖的问题。</p><h2 id="spring-bean-作用域" tabindex="-1"><a class="header-anchor" href="#spring-bean-作用域"><span>Spring Bean 作用域</span></a></h2><p>在 Spring 框架中，Bean 的作用域（Scope）定义了 Bean 实例的生命周期和可见性。以下是几种常见的作用域：</p><h3 id="singleton" tabindex="-1"><a class="header-anchor" href="#singleton"><span>Singleton</span></a></h3><ul><li><strong>描述</strong>：唯一 Bean 实例。</li><li><strong>特点</strong>：在 Spring 应用的整个生命周期中，每个由 Spring 容器管理的 singleton 作用域的 Bean 只有一个实例。</li><li><strong>使用场景</strong>：当 Bean 可以被多个地方安全共享时。</li></ul><h3 id="prototype" tabindex="-1"><a class="header-anchor" href="#prototype"><span>Prototype</span></a></h3><ul><li><strong>描述</strong>：每次请求都会创建一个新的 Bean 实例。</li><li><strong>特点</strong>：每次请求该 Bean 时，Spring 容器都会创建一个新的实例。</li><li><strong>使用场景</strong>：当 Bean 的实例化需要特定的配置或状态时。</li></ul><h3 id="request" tabindex="-1"><a class="header-anchor" href="#request"><span>Request</span></a></h3><ul><li><strong>描述</strong>：每一次 HTTP 请求都会产生一个新的 Bean。</li><li><strong>特点</strong>：Bean 的生命周期与 HTTP 请求相同，请求结束后 Bean 被销毁。</li><li><strong>使用场景</strong>：处理每个 HTTP 请求所需的临时数据。</li></ul><h3 id="session" tabindex="-1"><a class="header-anchor" href="#session"><span>Session</span></a></h3><ul><li><strong>描述</strong>：每一个 HTTP Session 会产生一个新的 Bean。</li><li><strong>特点</strong>：Bean 的生命周期与 HTTP 会话相同，会话结束后 Bean 被销毁。</li><li><strong>使用场景</strong>：当需要在同一个会话中保持 Bean 状态时。</li></ul><h2 id="异常处理类" tabindex="-1"><a class="header-anchor" href="#异常处理类"><span>异常处理类</span></a></h2><p>在 Spring 框架中，异常处理类用于集中处理应用程序中的异常。</p><h3 id="controlleradvice-1" tabindex="-1"><a class="header-anchor" href="#controlleradvice-1"><span>@ControllerAdvice</span></a></h3><ul><li>@ControllerAdvice 注解用于定义全局异常处理类。</li><li>它可以捕获控制器层抛出的异常，并进行统一处理。</li></ul><h3 id="exceptionhandler-1" tabindex="-1"><a class="header-anchor" href="#exceptionhandler-1"><span>@ExceptionHandler</span></a></h3><ul><li>@ExceptionHandler 注解声明异常处理方法。</li><li>用于指定哪些异常将由特定的处理方法来处理。</li></ul><hr><h2 id="jpa注解" tabindex="-1"><a class="header-anchor" href="#jpa注解"><span>JPA注解</span></a></h2><p>JPA（Java Persistence API）提供了一系列的注解，用于实体映射和操作。</p><h3 id="entity" tabindex="-1"><a class="header-anchor" href="#entity"><span>@Entity</span></a></h3><ul><li>@Entity 注解声明一个类对应一个数据库实体。</li><li>被注解的类将映射到数据库中的一个表。</li></ul><h3 id="id" tabindex="-1"><a class="header-anchor" href="#id"><span>@Id</span></a></h3><ul><li>@Id 注解声明一个字段为主键。</li><li>使用 @Id 注解后，需要定义主键的生成策略。</li></ul><h3 id="generatedvalue" tabindex="-1"><a class="header-anchor" href="#generatedvalue"><span>@GeneratedValue</span></a></h3><ul><li>@GeneratedValue 注解指定主键生成策略。</li><li>例如，可以使用 @GeneratedValue(strategy = GenerationType.IDENTITY) 来指定主键的生成策略。</li></ul><h3 id="transient" tabindex="-1"><a class="header-anchor" href="#transient"><span>@Transient</span></a></h3><ul><li>@Transient 注解声明不需要与数据库映射的字段。</li><li>被注解的字段在保存时不会被保存到数据库中。</li></ul><hr><h2 id="事务管理" tabindex="-1"><a class="header-anchor" href="#事务管理"><span>事务管理</span></a></h2><h3 id="transactional" tabindex="-1"><a class="header-anchor" href="#transactional"><span>@Transactional</span></a></h3><ul><li>@Transactional 注解用于声明事务管理。</li><li>可以指定在遇到特定异常时进行回滚。</li><li>例如，@Transactional(rollbackFor = Exception.class) 让事务在遇到非运行时异常时也回滚。</li></ul><h2 id="spring事务传播行为" tabindex="-1"><a class="header-anchor" href="#spring事务传播行为"><span>spring事务传播行为</span></a></h2><p>事务传播是指一个事务调用另一个事务时，这个事务方法对另一个事务方法（调用者）的态度，a\\b方法开启事务，a方法中调用了B方法，b方法传播到a方法的事务中，产生传播行为，这时我们需要对b方法进行处理。 他分7种：</p><p>第一种b在运行时需要事务，require,required-new，mandatory{抛异常}</p><p>第二种b在运行时不需要事务，supports,{有融入}not supported{有挂起}，never{有抛异常}</p><p>Nested支持嵌套事务，实现独立回滚</p><h2 id="dao接口工作原理" tabindex="-1"><a class="header-anchor" href="#dao接口工作原理"><span>DAO接口工作原理</span></a></h2><p>其工作原理时JDK动态代理， mybatis运行时会为dao接口生成动态代理对象，</p><p>对象会拦截方法，执行mappedstatement 的sql</p><h2 id="spring-框架中的设计模式" tabindex="-1"><a class="header-anchor" href="#spring-框架中的设计模式"><span>Spring 框架中的设计模式</span></a></h2><p>Spring 框架广泛地应用了多种设计模式，以下是一些主要的设计模式及其在 Spring 中的应用：</p><h3 id="工厂模式-factory-pattern" tabindex="-1"><a class="header-anchor" href="#工厂模式-factory-pattern"><span>工厂模式 (Factory Pattern)</span></a></h3><ul><li><strong>应用</strong>：BeanFactory 就用到了工厂模式。</li><li><strong>描述</strong>：工厂模式用于创建对象，而无需指定确切的类。Spring 通过 BeanFactory 提供了一个创建对象的接口。</li></ul><h3 id="单例模式-singleton-pattern" tabindex="-1"><a class="header-anchor" href="#单例模式-singleton-pattern"><span>单例模式 (Singleton Pattern)</span></a></h3><ul><li><strong>应用</strong>：Bean 的单例模式。</li><li><strong>描述</strong>：确保一个类只有一个实例，并提供一个全局访问点。Spring 中的 Bean 默认是单例的。</li></ul><h3 id="代理模式-proxy-pattern" tabindex="-1"><a class="header-anchor" href="#代理模式-proxy-pattern"><span>代理模式 (Proxy Pattern)</span></a></h3><ul><li><strong>应用</strong>：AOP 用到 JDK 的代理模式。</li><li><strong>描述</strong>：代理模式为其他对象提供一个代理以控制对这个对象的访问。Spring AOP（面向切面编程）功能就是基于代理模式实现的。</li></ul><h3 id="模板模式-template-pattern" tabindex="-1"><a class="header-anchor" href="#模板模式-template-pattern"><span>模板模式 (Template Pattern)</span></a></h3><ul><li><strong>应用</strong>：JDBC 模板。</li><li><strong>描述</strong>：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Spring 的 JdbcTemplate 就是模板模式的体现，它定义了数据库操作的通用步骤。</li></ul><h3 id="观察者模式-observer-pattern" tabindex="-1"><a class="header-anchor" href="#观察者模式-observer-pattern"><span>观察者模式 (Observer Pattern)</span></a></h3><ul><li><strong>应用</strong>：Spring 监听器的实现。</li><li><strong>描述</strong>：定义对象间的一种一对多的依赖关系，当一个对象改变状态时，所有依赖于它的对象都得到通知并被自动更新。Spring 事件监听器就是观察者模式的应用。</li></ul><h2 id="spring-boot-简介" tabindex="-1"><a class="header-anchor" href="#spring-boot-简介"><span>Spring Boot 简介</span></a></h2><p>Spring Boot 是一个基于 Spring 框架的快速开发框架，它简化了基于 Spring 的应用开发，提供了快速启动和部署 Spring 应用的能力。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ol><li><strong>自动依赖管理</strong>：</li></ol><ul><li>spring-boot-starter-web 会自动依赖其他组件，减少 Maven 配置。</li></ul><ol start="2"><li><strong>解决 Maven 依赖冲突</strong>：</li></ol><ul><li>Spring Boot 通过管理依赖版本来帮助解决 Maven 依赖冲突。</li></ul><ol start="3"><li><strong>内置服务器</strong>：</li></ol><ul><li>内置 Tomcat、Jetty、Undertow 等服务器，不需要打成 WAR 包，只需要打成可执行的 JAR 包就可以执行，所有依赖包都在一个 JAR 包中。</li></ul><ol start="4"><li><strong>自动装配 Bean</strong>：</li></ol><ul><li>Spring Boot 会根据当前类路径下的类自动装配 Bean，例如添加 spring-boot-starter-web 就能拥有 Web 功能。</li></ul><ol start="5"><li><strong>无 XML 配置</strong>：</li></ol><ul><li>配置过程无需 XML 文件就能完成所有配置工作，通过注解和 application.properties 或 application.yml 文件进行配置。</li></ul><div class="hint-container tip"><p class="hint-container-title">配置文件类型</p><p>properties优先加载级大于yml。</p></div><h2 id="spring-boot-核心注解" tabindex="-1"><a class="header-anchor" href="#spring-boot-核心注解"><span>Spring Boot 核心注解</span></a></h2><p>Spring Boot 提供了一系列注解来简化 Spring 应用的开发，以下是几个核心注解：</p><h3 id="springbootapplication" tabindex="-1"><a class="header-anchor" href="#springbootapplication"><span>@SpringBootApplication</span></a></h3><ul><li>组合注解，包含了 @SpringBootConfiguration、@EnableAutoConfiguration 和 @ComponentScan。</li><li>表明这是一个 Spring Boot 应用的启动类。</li></ul><h3 id="springbootconfiguration" tabindex="-1"><a class="header-anchor" href="#springbootconfiguration"><span>@SpringBootConfiguration</span></a></h3><ul><li>标识这是一个 Spring Boot 配置类。</li></ul><h3 id="enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#enableautoconfiguration"><span>@EnableAutoConfiguration</span></a></h3><ul><li>像容器中导入一个 selector，扫描 classpath 下的自动配置类，将这些自动加载为配置类。</li></ul><h3 id="componentscan" tabindex="-1"><a class="header-anchor" href="#componentscan"><span>@ComponentScan</span></a></h3><ul><li>标识扫描路径，默认扫描的是启动类所在的当前目录。</li><li>用于扫描并注册 Spring 组件，如 @Component、@Service、@Repository 和 @Controller 等。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>可以实现applicationrunner、commandlinerunner接口的runner方法实现，</p><p>可以用来进行一些定时任务（？），当然启动类也可以，在main方法中书写执行代码</p></div><h2 id="spring-设计模式" tabindex="-1"><a class="header-anchor" href="#spring-设计模式"><span>Spring 设计模式</span></a></h2><p>Spring 框架中广泛使用了多种设计模式，以下是一些核心的设计模式及其应用：</p><h3 id="控制反转-ioc-模式" tabindex="-1"><a class="header-anchor" href="#控制反转-ioc-模式"><span>控制反转 (IoC) 模式</span></a></h3><ul><li><strong>描述</strong>：将对象的创建交给 Spring 管理，实现了依赖的注入 (DI)。</li><li><strong>应用</strong>：通过 @Autowired 注解注解实现 Bean 之间的依赖注入。</li></ul><h3 id="工厂模式" tabindex="-1"><a class="header-anchor" href="#工厂模式"><span>工厂模式</span></a></h3><ul><li><strong>描述</strong>：ApplicationContext 即 Spring 容器，充当工厂类，负责创建 Bean 实例。</li><li><strong>应用</strong>：通过配置文件或注解定义 Bean 的创建逻辑。</li></ul><h3 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式"><span>单例模式</span></a></h3><ul><li><strong>描述</strong>：ApplicationContext 是一个单例 Bean，而每个 Bean 默认也是单例的。</li><li><strong>应用</strong>：确保 Bean 在整个应用程序中只有一个实例。</li></ul><h3 id="模板方法模式" tabindex="-1"><a class="header-anchor" href="#模板方法模式"><span>模板方法模式</span></a></h3><ul><li><strong>描述</strong>：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。</li><li><strong>应用</strong>：RedisTemplate 提供了一套统一的操作 Redis 的方法。</li></ul><h3 id="观察者模式" tabindex="-1"><a class="header-anchor" href="#观察者模式"><span>观察者模式</span></a></h3><ul><li><strong>描述</strong>：定义对象间的一种一对多的依赖关系，当一个对象改变状态时，所有依赖于它的对象都得到通知并被自动更新。</li><li><strong>应用</strong>：基于事件驱动的编程方式，如 ApplicationEvent、ApplicationListener。</li></ul><h3 id="策略模式" tabindex="-1"><a class="header-anchor" href="#策略模式"><span>策略模式</span></a></h3><ul><li><strong>描述</strong>：使用面向接口的编程思想定义策略层。</li><li><strong>应用</strong>：如 AuthenticationManager 策略接口等。</li></ul><h3 id="代理模式" tabindex="-1"><a class="header-anchor" href="#代理模式"><span>代理模式</span></a></h3><ul><li><strong>描述</strong>：为其他对象提供一个代理以控制对这个对象的访问。</li><li><strong>应用</strong>：AOP（面向切面编程）使用动态代理方式。</li></ul><h2 id="适配器模式" tabindex="-1"><a class="header-anchor" href="#适配器模式"><span>适配器模式</span></a></h2><ul><li><strong>描述</strong>：允许接口不兼容的类可以一起工作。</li><li><strong>应用</strong>：如 AdvisorAdapter 等，可以让任意类匹配某接口。</li></ul><h2 id="spring-mvc-请求处理流程" tabindex="-1"><a class="header-anchor" href="#spring-mvc-请求处理流程"><span>Spring MVC 请求处理流程</span></a></h2><p>Spring MVC 框架处理客户端请求的流程如下：</p><ol><li><strong>发送请求</strong>：</li></ol><ul><li>客户端（通常是浏览器）发送一个 HTTP 请求到服务器。</li></ul><ol start="2"><li><strong>请求处理</strong>：</li></ol><ul><li>请求被 Spring 的 <code>DispatcherServlet</code> 捕获，它是 Spring MVC 的前端控制器。</li></ul><ol start="3"><li><strong>请求映射</strong>：</li></ol><ul><li><code>DispatcherServlet</code> 使用 <code>HandlerMapping</code> 来确定请求应该由哪个控制器（<code>Controller</code>）处理。</li></ul><ol start="4"><li><strong>调用控制器</strong>：</li></ol><ul><li><code>DispatcherServlet</code> 调用匹配的控制器方法。</li></ul><ol start="5"><li><strong>业务逻辑</strong>：</li></ol><ul><li>控制器执行业务逻辑，可能包括调用服务层和数据访问层。</li></ul><ol start="6"><li><strong>返回视图</strong>：</li></ol><ul><li>控制器返回一个视图名称，通常通过 <code>ModelAndView</code> 对象。</li></ul><ol start="7"><li><strong>视图解析</strong>：</li></ol><ul><li><code>DispatcherServlet</code> 使用 <code>ViewResolver</code> 来解析视图名称，并找到实际的视图模板。</li></ul><ol start="8"><li><strong>渲染响应</strong>：</li></ol><ul><li>视图模板（如 JSP、Thymeleaf 等）被渲染成 HTML 内容。</li></ul><ol start="9"><li><strong>返回客户端</strong>：</li></ol><ul><li>最终的响应（包括 HTML 内容）被发送回客户端。</li></ul>`,227)]))}const p=l(s,[["render",t]]),c=JSON.parse('{"path":"/js/boot.html","title":"springboot","lang":"zh-CN","frontmatter":{"title":"springboot","author":"chengp"},"headers":[{"level":2,"title":"Spring IoC 容器构建","slug":"spring-ioc-容器构建","link":"#spring-ioc-容器构建","children":[]},{"level":2,"title":"Spring Boot 与 Spring MVC 的区别","slug":"spring-boot-与-spring-mvc-的区别","link":"#spring-boot-与-spring-mvc-的区别","children":[{"level":3,"title":"Spring Boot","slug":"spring-boot","link":"#spring-boot","children":[]},{"level":3,"title":"Spring MVC","slug":"spring-mvc","link":"#spring-mvc","children":[]},{"level":3,"title":"Spring Cloud","slug":"spring-cloud","link":"#spring-cloud","children":[]},{"level":3,"title":"Spring Boot 与 Spring MVC 的关系","slug":"spring-boot-与-spring-mvc-的关系","link":"#spring-boot-与-spring-mvc-的关系","children":[]}]},{"level":2,"title":"Controller 与 RestController 的区别","slug":"controller-与-restcontroller-的区别","link":"#controller-与-restcontroller-的区别","children":[{"level":3,"title":"RestController","slug":"restcontroller","link":"#restcontroller","children":[]},{"level":3,"title":"Controller","slug":"controller","link":"#controller","children":[]},{"level":3,"title":"@ResponseBody","slug":"responsebody","link":"#responsebody","children":[]}]},{"level":2,"title":"Spring Boot 自动配置类","slug":"spring-boot-自动配置类","link":"#spring-boot-自动配置类","children":[{"level":3,"title":"工作流程总结","slug":"工作流程总结","link":"#工作流程总结","children":[]}]},{"level":2,"title":"Spring 注解概览","slug":"spring-注解概览","link":"#spring-注解概览","children":[{"level":3,"title":"@Component 与 @Bean","slug":"component-与-bean","link":"#component-与-bean","children":[]},{"level":3,"title":"@Autowired 与 @Resource","slug":"autowired-与-resource","link":"#autowired-与-resource","children":[]}]},{"level":2,"title":"@Bean 的生命周期","slug":"bean-的生命周期","link":"#bean-的生命周期","children":[]},{"level":2,"title":"Bean 的线程安全性","slug":"bean-的线程安全性","link":"#bean-的线程安全性","children":[{"level":3,"title":"有状态 Bean","slug":"有状态-bean","link":"#有状态-bean","children":[]},{"level":3,"title":"无状态 Bean","slug":"无状态-bean","link":"#无状态-bean","children":[]}]},{"level":2,"title":"Spring MVC 工作原理","slug":"spring-mvc-工作原理","link":"#spring-mvc-工作原理","children":[]},{"level":2,"title":"统一异常处理","slug":"统一异常处理","link":"#统一异常处理","children":[{"level":3,"title":"@ControllerAdvice","slug":"controlleradvice","link":"#controlleradvice","children":[]},{"level":3,"title":"@ExceptionHandler","slug":"exceptionhandler","link":"#exceptionhandler","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]}]},{"level":2,"title":"循环依赖及其解决方案","slug":"循环依赖及其解决方案","link":"#循环依赖及其解决方案","children":[{"level":3,"title":"使用@Lazy注解","slug":"使用-lazy注解","link":"#使用-lazy注解","children":[]},{"level":3,"title":"三级缓存机制","slug":"三级缓存机制","link":"#三级缓存机制","children":[]},{"level":3,"title":"处理循环依赖","slug":"处理循环依赖","link":"#处理循环依赖","children":[]}]},{"level":2,"title":"Spring Bean 作用域","slug":"spring-bean-作用域","link":"#spring-bean-作用域","children":[{"level":3,"title":"Singleton","slug":"singleton","link":"#singleton","children":[]},{"level":3,"title":"Prototype","slug":"prototype","link":"#prototype","children":[]},{"level":3,"title":"Request","slug":"request","link":"#request","children":[]},{"level":3,"title":"Session","slug":"session","link":"#session","children":[]}]},{"level":2,"title":"异常处理类","slug":"异常处理类","link":"#异常处理类","children":[{"level":3,"title":"@ControllerAdvice","slug":"controlleradvice-1","link":"#controlleradvice-1","children":[]},{"level":3,"title":"@ExceptionHandler","slug":"exceptionhandler-1","link":"#exceptionhandler-1","children":[]}]},{"level":2,"title":"JPA注解","slug":"jpa注解","link":"#jpa注解","children":[{"level":3,"title":"@Entity","slug":"entity","link":"#entity","children":[]},{"level":3,"title":"@Id","slug":"id","link":"#id","children":[]},{"level":3,"title":"@GeneratedValue","slug":"generatedvalue","link":"#generatedvalue","children":[]},{"level":3,"title":"@Transient","slug":"transient","link":"#transient","children":[]}]},{"level":2,"title":"事务管理","slug":"事务管理","link":"#事务管理","children":[{"level":3,"title":"@Transactional","slug":"transactional","link":"#transactional","children":[]}]},{"level":2,"title":"spring事务传播行为","slug":"spring事务传播行为","link":"#spring事务传播行为","children":[]},{"level":2,"title":"DAO接口工作原理","slug":"dao接口工作原理","link":"#dao接口工作原理","children":[]},{"level":2,"title":"Spring 框架中的设计模式","slug":"spring-框架中的设计模式","link":"#spring-框架中的设计模式","children":[{"level":3,"title":"工厂模式 (Factory Pattern)","slug":"工厂模式-factory-pattern","link":"#工厂模式-factory-pattern","children":[]},{"level":3,"title":"单例模式 (Singleton Pattern)","slug":"单例模式-singleton-pattern","link":"#单例模式-singleton-pattern","children":[]},{"level":3,"title":"代理模式 (Proxy Pattern)","slug":"代理模式-proxy-pattern","link":"#代理模式-proxy-pattern","children":[]},{"level":3,"title":"模板模式 (Template Pattern)","slug":"模板模式-template-pattern","link":"#模板模式-template-pattern","children":[]},{"level":3,"title":"观察者模式 (Observer Pattern)","slug":"观察者模式-observer-pattern","link":"#观察者模式-observer-pattern","children":[]}]},{"level":2,"title":"Spring Boot 简介","slug":"spring-boot-简介","link":"#spring-boot-简介","children":[{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]}]},{"level":2,"title":"Spring Boot 核心注解","slug":"spring-boot-核心注解","link":"#spring-boot-核心注解","children":[{"level":3,"title":"@SpringBootApplication","slug":"springbootapplication","link":"#springbootapplication","children":[]},{"level":3,"title":"@SpringBootConfiguration","slug":"springbootconfiguration","link":"#springbootconfiguration","children":[]},{"level":3,"title":"@EnableAutoConfiguration","slug":"enableautoconfiguration","link":"#enableautoconfiguration","children":[]},{"level":3,"title":"@ComponentScan","slug":"componentscan","link":"#componentscan","children":[]}]},{"level":2,"title":"Spring 设计模式","slug":"spring-设计模式","link":"#spring-设计模式","children":[{"level":3,"title":"控制反转 (IoC) 模式","slug":"控制反转-ioc-模式","link":"#控制反转-ioc-模式","children":[]},{"level":3,"title":"工厂模式","slug":"工厂模式","link":"#工厂模式","children":[]},{"level":3,"title":"单例模式","slug":"单例模式","link":"#单例模式","children":[]},{"level":3,"title":"模板方法模式","slug":"模板方法模式","link":"#模板方法模式","children":[]},{"level":3,"title":"观察者模式","slug":"观察者模式","link":"#观察者模式","children":[]},{"level":3,"title":"策略模式","slug":"策略模式","link":"#策略模式","children":[]},{"level":3,"title":"代理模式","slug":"代理模式","link":"#代理模式","children":[]}]},{"level":2,"title":"适配器模式","slug":"适配器模式","link":"#适配器模式","children":[]},{"level":2,"title":"Spring MVC 请求处理流程","slug":"spring-mvc-请求处理流程","link":"#spring-mvc-请求处理流程","children":[]}],"git":{"updatedTime":1748331469000,"contributors":[{"name":"“root”","username":"","email":"1787536379@qq.com","commits":4}],"changelog":[{"hash":"d95c5586ec48bde22b3c35e6610e081db4b35fda","time":1748331469000,"email":"1787536379@qq.com","author":"“root”","message":"add 学习文档"},{"hash":"5060321abaa67e9154b1456a9d36705be88f8f8e","time":1748329949000,"email":"1787536379@qq.com","author":"“root”","message":"add 学习文档"},{"hash":"2f28edffd20e17e141c8d3f074c0c15dbcd3bc6c","time":1748231170000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"},{"hash":"baea1a08a6651d0396c2540bec53bd76e83874a0","time":1748220233000,"email":"1787536379@qq.com","author":"“root”","message":"lock content 1.0"}]},"filePathRelative":"js/boot.md","excerpt":"<h2>Spring IoC 容器构建</h2>\\n<ul>\\n<li>\\n<p>获取一个新的 bean 工厂：通常是 ApplicationContext</p>\\n</li>\\n<li>\\n<p>加载和解析 spring 的配置，解析 bean 对象，将解析到的 bean 封装成 BeanDefinition，并放到本地缓存中</p>\\n</li>\\n<li>\\n<p>实例化和调用 BeanFactoryPostProcessor (BeanDefinitionRegistryPostProcessor) 的扩展方法，这边是一个非常重要的扩展点</p>\\n</li>\\n<li>\\n<p>实例化 BeanPostProcessor，加载到 BeanFactory 中，但是这边还不触发，该扩展接口的方法在 bean 对象执行初始化方法前后被触发，这边是另一个重要扩展点</p>\\n</li>\\n<li>\\n<p>实例化所有剩余的 bean 实例（非懒加载），包括：创建 bean 实例、bean 实例属性填充、bean 实例的初始化</p>\\n</li>\\n<li>\\n<p>完成容器刷新，推送上下文刷新完毕事件（ContextRefreshedEvent）到监听器</p>\\n</li>\\n</ul>"}');export{p as comp,c as data};

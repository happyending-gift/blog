import{_ as e,c as r,a as l,o as c}from"./app-CFIQTifQ.js";const t={};function o(n,a){return c(),r("div",null,a[0]||(a[0]=[l('<h2 id="threadlocalmap的引用类型" tabindex="-1"><a class="header-anchor" href="#threadlocalmap的引用类型"><span>ThreadLocalMap的引用类型</span></a></h2><div class="hint-container tip"><p class="hint-container-title">answer</p><p>ThreadLocalMap 的 key 是弱引用，而 value 是强引用？</p></div><h3 id="为什么-threadlocalmap-的键-key-是弱引用-weak-reference" tabindex="-1"><a class="header-anchor" href="#为什么-threadlocalmap-的键-key-是弱引用-weak-reference"><span>为什么 ThreadLocalMap 的键（Key）是弱引用（Weak Reference）？</span></a></h3><p>ThreadLocalMap 是线程的成员变量，只要线程还未结束，它就会一直被线程强引用。如果我们假设 ThreadLocalMap 中的 Entry 对象的键是对 ThreadLocal 对象的强引用，那么这个 Entry 将持有 ThreadLocal 对象和值对象的强引用。如果在其他地方没有对这个 ThreadLocal 对象的引用，并且在使用 ThreadLocalMap 的过程中没有正确地在用完后就调用 remove() 方法，那么这个 ThreadLocal 对象和所关联的值对象就会随着线程一直存在，这样可能会造成内存泄漏问题。 特别是在使用线程池的时候，核心线程会一直存在直到程序结束。如果这些线程中的 ThreadLocalMap 中的数据没有被及时清理，就会一直占用内存，而且在线程复用时可能会导致数据错乱的危险。 如果 Entry 的键是对 ThreadLocal 对象的弱引用：弱引用意味着，如果没有其他引用对象的强引用关系，那么这个仅被弱引用的对象在下次垃圾回收（GC）时就会被回收掉，这样在一定程度上降低了内存泄漏的风险。但同时也引入了新的问题，即键虽然被回收了，但是值对象还在，我们无法获取，也无法删除，这样也会存在内存泄漏的风险。虽然 ThreadLocalMap 中在进行 set 和 get 操作时会进行启发式清理和探测式清理，清理一部分键为 null 的 Entry 对象，但是这只是一种后备选择，最重要的还是开发人员在编写代码时记得在使用完数据后及时调用 remove() 方法手动清理。</p><div class="hint-container tip"><p class="hint-container-title">内存泄漏</p><p>有些对象已经不再使用了，但是由于没有正确处理对象的引用关系，使得这个无用的对象还一直被 GC Root 直接或间接引用着，垃圾回收时就无法清理掉这些对象，如果这类对象存在很多，就会导致内存泄漏。</p></div><p>###为什么 ThreadLocalMap的值（Value）是强引用？ ：如果值是弱引用，那么在没有其他强引用指向这个值的情况下，值可能会在任何时候被垃圾回收器回收。这将导致 ThreadLocal 无法正确地存储和检索数据，因为它们可能会在不被期望的情况下突然消失。 强引用保证数据完整性：使用强引用作为 ThreadLocalMap<code>的值确保了只要</code>ThreadLocal对象存在，其关联的数据值也会一直存在，直到显式地通过remove()方法或线程结束时清理。这样可以保证数据的完整性和一致性，避免因垃圾回收导致的潜在错误。</p>',6)]))}const d=e(t,[["render",o]]),p=JSON.parse('{"path":"/js/JUC.html","title":"多线程","lang":"zh-CN","frontmatter":{"title":"多线程"},"headers":[{"level":2,"title":"ThreadLocalMap的引用类型","slug":"threadlocalmap的引用类型","link":"#threadlocalmap的引用类型","children":[{"level":3,"title":"为什么 ThreadLocalMap 的键（Key）是弱引用（Weak Reference）？","slug":"为什么-threadlocalmap-的键-key-是弱引用-weak-reference","link":"#为什么-threadlocalmap-的键-key-是弱引用-weak-reference","children":[]}]}],"git":{"updatedTime":1747498950000,"contributors":[{"name":"“root”","username":"","email":"1787536379@qq.com","commits":1}],"changelog":[{"hash":"11f0fe4ec4ced75ec5a83d62d288f5172be2017a","time":1747498950000,"email":"1787536379@qq.com","author":"“root”","message":"第一个总结上传"}]},"filePathRelative":"js/JUC.md","excerpt":"<h2>ThreadLocalMap的引用类型</h2>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">answer</p>\\n<p>ThreadLocalMap 的 key 是弱引用，而 value 是强引用？</p>\\n</div>\\n<h3>为什么 ThreadLocalMap 的键（Key）是弱引用（Weak Reference）？</h3>\\n<p>ThreadLocalMap 是线程的成员变量，只要线程还未结束，它就会一直被线程强引用。如果我们假设 ThreadLocalMap 中的 Entry 对象的键是对 ThreadLocal 对象的强引用，那么这个 Entry 将持有 ThreadLocal 对象和值对象的强引用。如果在其他地方没有对这个 ThreadLocal 对象的引用，并且在使用 ThreadLocalMap 的过程中没有正确地在用完后就调用 remove() 方法，那么这个 ThreadLocal 对象和所关联的值对象就会随着线程一直存在，这样可能会造成内存泄漏问题。\\n特别是在使用线程池的时候，核心线程会一直存在直到程序结束。如果这些线程中的 ThreadLocalMap 中的数据没有被及时清理，就会一直占用内存，而且在线程复用时可能会导致数据错乱的危险。\\n如果 Entry 的键是对 ThreadLocal 对象的弱引用：弱引用意味着，如果没有其他引用对象的强引用关系，那么这个仅被弱引用的对象在下次垃圾回收（GC）时就会被回收掉，这样在一定程度上降低了内存泄漏的风险。但同时也引入了新的问题，即键虽然被回收了，但是值对象还在，我们无法获取，也无法删除，这样也会存在内存泄漏的风险。虽然 ThreadLocalMap 中在进行 set 和 get 操作时会进行启发式清理和探测式清理，清理一部分键为 null 的 Entry 对象，但是这只是一种后备选择，最重要的还是开发人员在编写代码时记得在使用完数据后及时调用 remove() 方法手动清理。</p>"}');export{d as comp,p as data};

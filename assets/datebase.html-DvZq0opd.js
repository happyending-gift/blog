import{_ as a,c as n,a as l,o as t}from"./app-CQ3tvoA0.js";const i={};function r(s,e){return t(),n("div",null,e[0]||(e[0]=[l('<h2 id="并发数据库操作中的读取问题" tabindex="-1"><a class="header-anchor" href="#并发数据库操作中的读取问题"><span>并发数据库操作中的读取问题</span></a></h2><p>在并发数据库操作中，可能会出现脏读、不可重复读和幻读等问题，这些问题都与事务的隔离级别有关。</p><h3 id="脏读-dirty-read" tabindex="-1"><a class="header-anchor" href="#脏读-dirty-read"><span>脏读 (Dirty Read)</span></a></h3><ul><li><strong>定义</strong>：一个事务读取到了另一个事务未提交的数据。</li><li><strong>影响</strong>：如果未提交的事务最终被回滚，那么读取到的数据就是无效的，这可能导致错误的决策。</li></ul><h3 id="不可重复读-non-repeatable-read" tabindex="-1"><a class="header-anchor" href="#不可重复读-non-repeatable-read"><span>不可重复读 (Non-repeatable Read)</span></a></h3><ul><li><strong>定义</strong>：在一个事务中多次读取同一数据，如果在两次读取之间，其他事务对数据进行了修改，那么两次读取的数据可能不一致。</li><li><strong>影响</strong>：这可能导致事务在处理过程中得到不同的结果，影响数据的一致性。</li></ul><h3 id="幻读-phantom-read" tabindex="-1"><a class="header-anchor" href="#幻读-phantom-read"><span>幻读 (Phantom Read)</span></a></h3><ul><li><strong>定义</strong>：在一个事务中多次读取同一范围的数据，如果在两次读取之间，其他事务插入或删除了数据，那么两次读取的数据数量可能不一致。</li><li><strong>影响</strong>：这可能导致事务在处理过程中得到不一致的数据集，影响数据的完整性。</li></ul><h3 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别"><span>隔离级别</span></a></h3><p>为了解决这些问题，数据库系统提供了不同的事务隔离级别：</p><ol><li><strong>读未提交 (Read Uncommitted)</strong>：最低的隔离级别，可能出现脏读、不可重复读和幻读。</li><li><strong>读已提交 (Read Committed)</strong>：避免了脏读，但可能出现不可重复读和幻读。</li><li><strong>可重复读 (Repeatable Read)</strong>：避免了脏读和不可重复读，但可能出现幻读。</li><li><strong>串行化 (Serializable)</strong>：最高的隔离级别，避免了脏读、不可重复读和幻读，但性能开销较大。</li></ol><h2 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引"><span>聚簇索引</span></a></h2><p>根据ID构建，且叶子节点保存所有行数据的索引，称之为聚簇索引，</p><p>他是存储MYSQL里面数据的基本结构，所以跟据ID数据查询时可以走聚簇索引，但要是不是ID就不能走聚簇索引。</p><h2 id="非聚簇索引-二级索引" tabindex="-1"><a class="header-anchor" href="#非聚簇索引-二级索引"><span>非聚簇索引（二级索引）</span></a></h2><p>叶子节点存储的是聚簇索引的字段，之后需要回表走聚簇索引，因为没有覆盖查询所需要的数据</p><h2 id="索引覆盖-减少回表次数" tabindex="-1"><a class="header-anchor" href="#索引覆盖-减少回表次数"><span>索引覆盖（减少回表次数）</span></a></h2><p>查询结果可以在二级索引获取，而无需访问表的实际数据，即无需回表查</p><h2 id="myisam-与-innodb-存储引擎的区别" tabindex="-1"><a class="header-anchor" href="#myisam-与-innodb-存储引擎的区别"><span>MyISAM 与 InnoDB 存储引擎的区别</span></a></h2><p>在 MySQL 数据库中，InnoDB 和 MyISAM 是两种常用的存储引擎，它们在事务支持、锁定级别、外键支持、ACID 支持以及性能方面各有特点。</p><h3 id="事务支持" tabindex="-1"><a class="header-anchor" href="#事务支持"><span>事务支持</span></a></h3><ul><li><strong>MyISAM</strong>：不支持事务处理。</li><li><strong>InnoDB</strong>：支持事务处理。</li></ul><h3 id="锁定级别" tabindex="-1"><a class="header-anchor" href="#锁定级别"><span>锁定级别</span></a></h3><ul><li><strong>MyISAM</strong>：使用表级锁定，即当一个线程读取一个表时，其他线程不能同时写入该表。</li><li><strong>InnoDB</strong>：支持行级锁定，允许更高的并发性。</li></ul><h3 id="外键支持" tabindex="-1"><a class="header-anchor" href="#外键支持"><span>外键支持</span></a></h3><ul><li><strong>MyISAM</strong>：不支持外键约束。</li><li><strong>InnoDB</strong>：支持外键约束，可以维护数据的引用完整性。</li></ul><h3 id="acid-支持" tabindex="-1"><a class="header-anchor" href="#acid-支持"><span>ACID 支持</span></a></h3><ul><li><strong>MyISAM</strong>：不完全支持 ACID 特性。</li><li><strong>InnoDB</strong>：完全支持 ACID 特性，确保事务的原子性、一致性、隔离性和持久性。</li></ul><h3 id="性能" tabindex="-1"><a class="header-anchor" href="#性能"><span>性能</span></a></h3><ul><li><p><strong>MyISAM</strong>：在读操作多、写操作少的场景下性能较好，尤其是在处理大量数据时。</p></li><li><p><strong>InnoDB</strong>：在处理大量并发读写操作时性能较好。</p></li><li><p>如果需要支持事务、外键约束或者需要更好的数据完整性和一致性，应选择 <strong>InnoDB</strong>。</p></li><li><p>如果需要更好的读性能，且不需要事务处理，可以选择 <strong>MyISAM</strong>。</p></li></ul><h2 id="索引失效" tabindex="-1"><a class="header-anchor" href="#索引失效"><span>索引失效</span></a></h2><p>索引列参与计算：如 WHERE age * 2 = 40，索引无法使用</p><p>对索引列进行函数操作：如 WHERE UPPER(name) = &#39;ZHANGSAN&#39;，索引会失效</p><p>查询中使用了 OR 两边有范围查询：如 WHERE age = 10 OR age &gt; 20，可能导致索引失效</p><p>LIKE操作：以 % 开头的 LIKE 查询，如 WHERE name LIKE &#39;%zhangsan&#39;，索引会失效</p><p>不等于比较：使用 != 或 &lt;&gt; 比较可能导致索引失效</p><p>IS NULL 或 IS NOT NULL：这些条件可能导致索引失效</p><p>字符串不加单引号：如 WHERE name = 2000，可能导致索引失效。隐式类型转换</p><p>使用 IN：当 IN 子句中的列表过大时，可能导致索引失效</p><p>使用 NOT IN：这可能导致索引失效，特别是当子查询返回大量数据时</p>',40)]))}const d=a(i,[["render",r]]),h=JSON.parse('{"path":"/js/datebase.html","title":"date_base","lang":"zh-CN","frontmatter":{"title":"date_base","author":"chengp"},"headers":[{"level":2,"title":"并发数据库操作中的读取问题","slug":"并发数据库操作中的读取问题","link":"#并发数据库操作中的读取问题","children":[{"level":3,"title":"脏读 (Dirty Read)","slug":"脏读-dirty-read","link":"#脏读-dirty-read","children":[]},{"level":3,"title":"不可重复读 (Non-repeatable Read)","slug":"不可重复读-non-repeatable-read","link":"#不可重复读-non-repeatable-read","children":[]},{"level":3,"title":"幻读 (Phantom Read)","slug":"幻读-phantom-read","link":"#幻读-phantom-read","children":[]},{"level":3,"title":"隔离级别","slug":"隔离级别","link":"#隔离级别","children":[]}]},{"level":2,"title":"聚簇索引","slug":"聚簇索引","link":"#聚簇索引","children":[]},{"level":2,"title":"非聚簇索引（二级索引）","slug":"非聚簇索引-二级索引","link":"#非聚簇索引-二级索引","children":[]},{"level":2,"title":"索引覆盖（减少回表次数）","slug":"索引覆盖-减少回表次数","link":"#索引覆盖-减少回表次数","children":[]},{"level":2,"title":"MyISAM 与 InnoDB 存储引擎的区别","slug":"myisam-与-innodb-存储引擎的区别","link":"#myisam-与-innodb-存储引擎的区别","children":[{"level":3,"title":"事务支持","slug":"事务支持","link":"#事务支持","children":[]},{"level":3,"title":"锁定级别","slug":"锁定级别","link":"#锁定级别","children":[]},{"level":3,"title":"外键支持","slug":"外键支持","link":"#外键支持","children":[]},{"level":3,"title":"ACID 支持","slug":"acid-支持","link":"#acid-支持","children":[]},{"level":3,"title":"性能","slug":"性能","link":"#性能","children":[]}]},{"level":2,"title":"索引失效","slug":"索引失效","link":"#索引失效","children":[]}],"git":{"updatedTime":1748240439000,"contributors":[{"name":"“root”","username":"","email":"1787536379@qq.com","commits":2}],"changelog":[{"hash":"7de995f7b2d57b6ed805b307410fa1c43160096b","time":1748240439000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"},{"hash":"2f28edffd20e17e141c8d3f074c0c15dbcd3bc6c","time":1748231170000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"}]},"filePathRelative":"js/datebase.md","excerpt":"<h2>并发数据库操作中的读取问题</h2>\\n<p>在并发数据库操作中，可能会出现脏读、不可重复读和幻读等问题，这些问题都与事务的隔离级别有关。</p>\\n<h3>脏读 (Dirty Read)</h3>\\n<ul>\\n<li><strong>定义</strong>：一个事务读取到了另一个事务未提交的数据。</li>\\n<li><strong>影响</strong>：如果未提交的事务最终被回滚，那么读取到的数据就是无效的，这可能导致错误的决策。</li>\\n</ul>\\n<h3>不可重复读 (Non-repeatable Read)</h3>\\n<ul>\\n<li><strong>定义</strong>：在一个事务中多次读取同一数据，如果在两次读取之间，其他事务对数据进行了修改，那么两次读取的数据可能不一致。</li>\\n<li><strong>影响</strong>：这可能导致事务在处理过程中得到不同的结果，影响数据的一致性。</li>\\n</ul>"}');export{d as comp,h as data};

import{_ as a,c as e,a as i,o as t}from"./app-CWkNsZeX.js";const n={};function r(h,l){return t(),e("div",null,l[0]||(l[0]=[i('<h2 id="引用拷贝、深拷贝、浅拷贝" tabindex="-1"><a class="header-anchor" href="#引用拷贝、深拷贝、浅拷贝"><span>引用拷贝、深拷贝、浅拷贝</span></a></h2><h3 id="引用拷贝" tabindex="-1"><a class="header-anchor" href="#引用拷贝"><span>引用拷贝</span></a></h3><ul><li>拷贝引用，两个不同的引用指向同一个对象。</li></ul><h3 id="深拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝"><span>深拷贝</span></a></h3><ul><li>完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><h3 id="浅拷贝" tabindex="-1"><a class="header-anchor" href="#浅拷贝"><span>浅拷贝</span></a></h3><ul><li>在堆上创建一个新的对象。</li><li>如果原对象内部的属性是引用类型，浅拷贝会直接复制内部对象的引用地址。</li></ul><h2 id="string、stringbuilder、stringbuffer" tabindex="-1"><a class="header-anchor" href="#string、stringbuilder、stringbuffer"><span>String、StringBuilder、StringBuffer</span></a></h2><h3 id="可变性" tabindex="-1"><a class="header-anchor" href="#可变性"><span>可变性</span></a></h3><ul><li>String：内部的 value 值是 char 数组，被 final 修饰，不可变。</li><li>StringBuilder 和 StringBuffer：可变。</li></ul><h3 id="安全性" tabindex="-1"><a class="header-anchor" href="#安全性"><span>安全性</span></a></h3><ul><li>String：由于不可变，所以是安全的。</li><li>StringBuilder：不是线程安全的。</li><li>StringBuffer：因为加了锁，所以是线程安全的。</li></ul><h3 id="性能方面" tabindex="-1"><a class="header-anchor" href="#性能方面"><span>性能方面</span></a></h3><ul><li>使用String进行拼接时需要创建新对象，性能最差。</li><li>StringBuffer因为加了锁影响性能，所以比StringBuilder性能差。</li></ul><hr><h2 id="自动拆装箱" tabindex="-1"><a class="header-anchor" href="#自动拆装箱"><span>自动拆装箱</span></a></h2><h3 id="装箱" tabindex="-1"><a class="header-anchor" href="#装箱"><span>装箱</span></a></h3><ul><li>将基本类型用它们对应的引用类型包装起来。</li></ul><h3 id="拆箱" tabindex="-1"><a class="header-anchor" href="#拆箱"><span>拆箱</span></a></h3><ul><li>将包装类型转换为基本数据类型。</li></ul><hr><h2 id="重载、重写" tabindex="-1"><a class="header-anchor" href="#重载、重写"><span>重载、重写</span></a></h2><h3 id="重载" tabindex="-1"><a class="header-anchor" href="#重载"><span>重载</span></a></h3><ul><li>同样的一个方法能够根据输入数据的不同，做出不同的处理。</li></ul><h3 id="重写" tabindex="-1"><a class="header-anchor" href="#重写"><span>重写</span></a></h3><ul><li>当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，覆盖父类方法。</li></ul><hr><h2 id="char、varchar" tabindex="-1"><a class="header-anchor" href="#char、varchar"><span>Char、Varchar</span></a></h2><h3 id="可变性-1" tabindex="-1"><a class="header-anchor" href="#可变性-1"><span>可变性</span></a></h3><ul><li>Char：不可变长度，数据长度不足会空格补充。</li><li>Varchar：可变长度。</li></ul><h3 id="性能方面-1" tabindex="-1"><a class="header-anchor" href="#性能方面-1"><span>性能方面</span></a></h3><ul><li>Char：不可变长度，性能更佳。</li><li>Varchar：更省空间。</li></ul><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><ul><li>Char：适用于记录固定表单数据，如身份证。</li><li>Varchar：适用于记录不固定数据，如昵称。</li></ul><hr><h2 id="和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#和-equals-的区别"><span>== 和 equals 的区别</span></a></h2><h3 id="" tabindex="-1"><a class="header-anchor" href="#"><span>==</span></a></h3><ul><li>比较栈中的值。 <ul><li>基本数据类型：比较数值是否相等。</li><li>引用数据类型：比较对象的内存地址是否相等。</li></ul></li></ul><h3 id="equals" tabindex="-1"><a class="header-anchor" href="#equals"><span>equals</span></a></h3><ul><li>重写前跟==一致。</li><li>重写后比较对象的内容是否相同。</li></ul><hr><h2 id="string-intern" tabindex="-1"><a class="header-anchor" href="#string-intern"><span>String.intern()</span></a></h2><p>将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用，并返回该引用。</li></ul><h2 id="static-关键字" tabindex="-1"><a class="header-anchor" href="#static-关键字"><span>Static 关键字</span></a></h2><p>static关键字用于修饰成员变量、方法体、内部类、代码块和静态导包。</p><h3 id="静态导包" tabindex="-1"><a class="header-anchor" href="#静态导包"><span>静态导包</span></a></h3><ul><li>允许直接使用类的方法，就像它是类自己的方法一样。</li></ul><h3 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类"><span>内部类</span></a></h3><ul><li>可以直接使用内部类，而不需要外部类。</li></ul><h2 id="java-异常类型及原理" tabindex="-1"><a class="header-anchor" href="#java-异常类型及原理"><span>Java 异常类型及原理</span></a></h2><p>Throwable有两个直接的子类：Error 和Exception。</p><p>Error</p><ul><li>无法恢复的错误，程序员不需要处理。</li></ul><p>Exception</p><ul><li>可恢复的异常，分为 RuntimeException和其他 Exception。 <ul><li><strong>RuntimeException</strong>：处理或不处理都可以。</li><li><strong>其他 Exception</strong>：Java 编译器要求程序必须捕获或抛出这种异常。</li></ul></li></ul><h2 id="字节流与字符流的区别" tabindex="-1"><a class="header-anchor" href="#字节流与字符流的区别"><span>字节流与字符流的区别</span></a></h2><table><thead><tr><th>特性</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>操作基本单元</td><td>字节 (byte)</td><td>字符 (char)</td></tr><tr><td>是否使用缓冲</td><td>否</td><td>是</td></tr><tr><td>存在位置</td><td>可存在于文件、内存中</td><td>只存在于内存中</td></tr><tr><td>使用场景</td><td>适合操作文本文件之外的文件</td><td>适合操作文本文件时使用，自动处理字符编码和解码</td></tr></tbody></table><h2 id="java-访问权限" tabindex="-1"><a class="header-anchor" href="#java-访问权限"><span>Java 访问权限</span></a></h2><table><thead><tr><th>访问修饰符</th><th>访问范围</th></tr></thead><tbody><tr><td>public</td><td>内部成员、子类、同包其他类、其他包</td></tr><tr><td>protected</td><td>内部成员、子类、同包其他类</td></tr><tr><td>default</td><td>内部成员、同包其他类</td></tr><tr><td>private</td><td>内部成员</td></tr></tbody></table><h2 id="接口知识" tabindex="-1"><a class="header-anchor" href="#接口知识"><span>接口知识</span></a></h2><h3 id="jdk-8-新特性" tabindex="-1"><a class="header-anchor" href="#jdk-8-新特性"><span>JDK 8 新特性</span></a></h3><ul><li><strong>default 方法</strong>：接口中可以包含方法体，修改接口时需要修改所有实现该接口的类。</li><li><strong>static 方法</strong>：static 修饰的方法可以放入接口中，可以直接用 &lt;接口名.方法名()&gt; 的形式调用。</li></ul><h3 id="匿名内部类" tabindex="-1"><a class="header-anchor" href="#匿名内部类"><span>匿名内部类</span></a></h3><ul><li>用于创建没有名称的类的实例。</li></ul><h2 id="java-中-integer-对象的自动装箱和-操作符" tabindex="-1"><a class="header-anchor" href="#java-中-integer-对象的自动装箱和-操作符"><span>Java 中 Integer 对象的自动装箱和 == 操作符</span></a></h2><ul><li>在 Java 中，Integer 对象使用了一个叫做 IntegerCache 的技术，</li><li>它缓存了数值在 -128 到 127 之间（包含 -128 和 127）的 Integer 对象。</li><li>这意味着在这个范围内的 Integer 对象都只有一个唯一的实例。</li></ul>',67)]))}const d=a(n,[["render",r]]),c=JSON.parse('{"path":"/js/javabase.html","title":"java基础","lang":"zh-CN","frontmatter":{"title":"java基础","author":"chengp"},"headers":[{"level":2,"title":"引用拷贝、深拷贝、浅拷贝","slug":"引用拷贝、深拷贝、浅拷贝","link":"#引用拷贝、深拷贝、浅拷贝","children":[{"level":3,"title":"引用拷贝","slug":"引用拷贝","link":"#引用拷贝","children":[]},{"level":3,"title":"深拷贝","slug":"深拷贝","link":"#深拷贝","children":[]},{"level":3,"title":"浅拷贝","slug":"浅拷贝","link":"#浅拷贝","children":[]}]},{"level":2,"title":"String、StringBuilder、StringBuffer","slug":"string、stringbuilder、stringbuffer","link":"#string、stringbuilder、stringbuffer","children":[{"level":3,"title":"可变性","slug":"可变性","link":"#可变性","children":[]},{"level":3,"title":"安全性","slug":"安全性","link":"#安全性","children":[]},{"level":3,"title":"性能方面","slug":"性能方面","link":"#性能方面","children":[]}]},{"level":2,"title":"自动拆装箱","slug":"自动拆装箱","link":"#自动拆装箱","children":[{"level":3,"title":"装箱","slug":"装箱","link":"#装箱","children":[]},{"level":3,"title":"拆箱","slug":"拆箱","link":"#拆箱","children":[]}]},{"level":2,"title":"重载、重写","slug":"重载、重写","link":"#重载、重写","children":[{"level":3,"title":"重载","slug":"重载","link":"#重载","children":[]},{"level":3,"title":"重写","slug":"重写","link":"#重写","children":[]}]},{"level":2,"title":"Char、Varchar","slug":"char、varchar","link":"#char、varchar","children":[{"level":3,"title":"可变性","slug":"可变性-1","link":"#可变性-1","children":[]},{"level":3,"title":"性能方面","slug":"性能方面-1","link":"#性能方面-1","children":[]},{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]}]},{"level":2,"title":"== 和 equals 的区别","slug":"和-equals-的区别","link":"#和-equals-的区别","children":[{"level":3,"title":"==","slug":"","link":"#","children":[]},{"level":3,"title":"equals","slug":"equals","link":"#equals","children":[]}]},{"level":2,"title":"String.intern()","slug":"string-intern","link":"#string-intern","children":[]},{"level":2,"title":"Static 关键字","slug":"static-关键字","link":"#static-关键字","children":[{"level":3,"title":"静态导包","slug":"静态导包","link":"#静态导包","children":[]},{"level":3,"title":"内部类","slug":"内部类","link":"#内部类","children":[]}]},{"level":2,"title":"Java 异常类型及原理","slug":"java-异常类型及原理","link":"#java-异常类型及原理","children":[]},{"level":2,"title":"字节流与字符流的区别","slug":"字节流与字符流的区别","link":"#字节流与字符流的区别","children":[]},{"level":2,"title":"Java 访问权限","slug":"java-访问权限","link":"#java-访问权限","children":[]},{"level":2,"title":"接口知识","slug":"接口知识","link":"#接口知识","children":[{"level":3,"title":"JDK 8 新特性","slug":"jdk-8-新特性","link":"#jdk-8-新特性","children":[]},{"level":3,"title":"匿名内部类","slug":"匿名内部类","link":"#匿名内部类","children":[]}]},{"level":2,"title":"Java 中 Integer 对象的自动装箱和 == 操作符","slug":"java-中-integer-对象的自动装箱和-操作符","link":"#java-中-integer-对象的自动装箱和-操作符","children":[]}],"git":{"updatedTime":1748329949000,"contributors":[{"name":"“root”","username":"","email":"1787536379@qq.com","commits":3}],"changelog":[{"hash":"5060321abaa67e9154b1456a9d36705be88f8f8e","time":1748329949000,"email":"1787536379@qq.com","author":"“root”","message":"add 学习文档"},{"hash":"7de995f7b2d57b6ed805b307410fa1c43160096b","time":1748240439000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"},{"hash":"2f28edffd20e17e141c8d3f074c0c15dbcd3bc6c","time":1748231170000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"}]},"filePathRelative":"js/javabase.md","excerpt":"<h2>引用拷贝、深拷贝、浅拷贝</h2>\\n<h3>引用拷贝</h3>\\n<ul>\\n<li>拷贝引用，两个不同的引用指向同一个对象。</li>\\n</ul>\\n<h3>深拷贝</h3>\\n<ul>\\n<li>完全复制整个对象，包括这个对象所包含的内部对象。</li>\\n</ul>\\n<h3>浅拷贝</h3>\\n<ul>\\n<li>在堆上创建一个新的对象。</li>\\n<li>如果原对象内部的属性是引用类型，浅拷贝会直接复制内部对象的引用地址。</li>\\n</ul>\\n<h2>String、StringBuilder、StringBuffer</h2>\\n<h3>可变性</h3>\\n<ul>\\n<li>String：内部的 value 值是 char 数组，被 final 修饰，不可变。</li>\\n<li>StringBuilder 和 StringBuffer：可变。</li>\\n</ul>"}');export{d as comp,c as data};

import{_ as n,c as e,a,o as i}from"./app-DI5GBXpc.js";const s={};function t(r,l){return i(),e("div",null,l[0]||(l[0]=[a(`<h2 id="并发数据库操作中的读取问题" tabindex="-1"><a class="header-anchor" href="#并发数据库操作中的读取问题"><span>并发数据库操作中的读取问题</span></a></h2><p>在并发数据库操作中，可能会出现脏读、不可重复读和幻读等问题，这些问题都与事务的隔离级别有关。</p><h3 id="脏读-dirty-read" tabindex="-1"><a class="header-anchor" href="#脏读-dirty-read"><span>脏读 (Dirty Read)</span></a></h3><ul><li><strong>定义</strong>：一个事务读取到了另一个事务未提交的数据。</li><li><strong>影响</strong>：如果未提交的事务最终被回滚，那么读取到的数据就是无效的，这可能导致错误的决策。</li></ul><h3 id="不可重复读-non-repeatable-read" tabindex="-1"><a class="header-anchor" href="#不可重复读-non-repeatable-read"><span>不可重复读 (Non-repeatable Read)</span></a></h3><ul><li><strong>定义</strong>：在一个事务中多次读取同一数据，如果在两次读取之间，其他事务对数据进行了修改，那么两次读取的数据可能不一致。</li><li><strong>影响</strong>：这可能导致事务在处理过程中得到不同的结果，影响数据的一致性。</li></ul><h3 id="幻读-phantom-read" tabindex="-1"><a class="header-anchor" href="#幻读-phantom-read"><span>幻读 (Phantom Read)</span></a></h3><ul><li><strong>定义</strong>：在一个事务中多次读取同一范围的数据，如果在两次读取之间，其他事务插入或删除了数据，那么两次读取的数据数量可能不一致。</li><li><strong>影响</strong>：这可能导致事务在处理过程中得到不一致的数据集，影响数据的完整性。</li></ul><h3 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别"><span>隔离级别</span></a></h3><p>为了解决这些问题，数据库系统提供了不同的事务隔离级别：</p><ol><li><strong>读未提交 (Read Uncommitted)</strong>：最低的隔离级别，可能出现脏读、不可重复读和幻读。</li><li><strong>读已提交 (Read Committed)</strong>：避免了脏读，但可能出现不可重复读和幻读。</li><li><strong>可重复读 (Repeatable Read)</strong>：避免了脏读和不可重复读，但可能出现幻读。</li><li><strong>串行化 (Serializable)</strong>：最高的隔离级别，避免了脏读、不可重复读和幻读，但性能开销较大。</li></ol><h2 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引"><span>聚簇索引</span></a></h2><p>根据ID构建，且叶子节点保存所有行数据的索引，称之为聚簇索引，</p><p>他是存储MYSQL里面数据的基本结构，所以跟据ID数据查询时可以走聚簇索引，但要是不是ID就不能走聚簇索引。</p><h2 id="非聚簇索引-二级索引" tabindex="-1"><a class="header-anchor" href="#非聚簇索引-二级索引"><span>非聚簇索引（二级索引）</span></a></h2><p>叶子节点存储的是聚簇索引的字段，之后需要回表走聚簇索引，因为没有覆盖查询所需要的数据</p><h2 id="索引覆盖-减少回表次数" tabindex="-1"><a class="header-anchor" href="#索引覆盖-减少回表次数"><span>索引覆盖（减少回表次数）</span></a></h2><p>查询结果可以在二级索引获取，而无需访问表的实际数据，即无需回表查</p><h2 id="myisam-与-innodb-存储引擎的区别" tabindex="-1"><a class="header-anchor" href="#myisam-与-innodb-存储引擎的区别"><span>MyISAM 与 InnoDB 存储引擎的区别</span></a></h2><p>在 MySQL 数据库中，InnoDB 和 MyISAM 是两种常用的存储引擎，它们在事务支持、锁定级别、外键支持、ACID 支持以及性能方面各有特点。</p><h3 id="事务支持" tabindex="-1"><a class="header-anchor" href="#事务支持"><span>事务支持</span></a></h3><ul><li><strong>MyISAM</strong>：不支持事务处理。</li><li><strong>InnoDB</strong>：支持事务处理。</li></ul><h3 id="锁定级别" tabindex="-1"><a class="header-anchor" href="#锁定级别"><span>锁定级别</span></a></h3><ul><li><strong>MyISAM</strong>：使用表级锁定，即当一个线程读取一个表时，其他线程不能同时写入该表。</li><li><strong>InnoDB</strong>：支持行级锁定，允许更高的并发性。</li></ul><h3 id="外键支持" tabindex="-1"><a class="header-anchor" href="#外键支持"><span>外键支持</span></a></h3><ul><li><strong>MyISAM</strong>：不支持外键约束。</li><li><strong>InnoDB</strong>：支持外键约束，可以维护数据的引用完整性。</li></ul><h3 id="acid-支持" tabindex="-1"><a class="header-anchor" href="#acid-支持"><span>ACID 支持</span></a></h3><ul><li><strong>MyISAM</strong>：不完全支持 ACID 特性。</li><li><strong>InnoDB</strong>：完全支持 ACID 特性，确保事务的原子性、一致性、隔离性和持久性。</li></ul><h3 id="性能" tabindex="-1"><a class="header-anchor" href="#性能"><span>性能</span></a></h3><ul><li><p><strong>MyISAM</strong>：在读操作多、写操作少的场景下性能较好，尤其是在处理大量数据时。</p></li><li><p><strong>InnoDB</strong>：在处理大量并发读写操作时性能较好。</p></li><li><p>如果需要支持事务、外键约束或者需要更好的数据完整性和一致性，应选择 <strong>InnoDB</strong>。</p></li><li><p>如果需要更好的读性能，且不需要事务处理，可以选择 <strong>MyISAM</strong>。</p></li></ul><h2 id="索引失效" tabindex="-1"><a class="header-anchor" href="#索引失效"><span>索引失效</span></a></h2><p>索引列参与计算：如 WHERE age * 2 = 40，索引无法使用</p><p>对索引列进行函数操作：如 WHERE UPPER(name) = &#39;ZHANGSAN&#39;，索引会失效</p><p>查询中使用了 OR 两边有范围查询：如 WHERE age = 10 OR age &gt; 20，可能导致索引失效</p><p>LIKE操作：以 % 开头的 LIKE 查询，如 WHERE name LIKE &#39;%zhangsan&#39;，索引会失效</p><p>不等于比较：使用 != 或 &lt;&gt; 比较可能导致索引失效</p><p>IS NULL 或 IS NOT NULL：这些条件可能导致索引失效</p><p>字符串不加单引号：如 WHERE name = 2000，可能导致索引失效。隐式类型转换</p><p>使用 IN：当 IN 子句中的列表过大时，可能导致索引失效</p><p>使用 NOT IN：这可能导致索引失效，特别是当子查询返回大量数据时</p><h2 id="drop、truncate、delete-操作比较" tabindex="-1"><a class="header-anchor" href="#drop、truncate、delete-操作比较"><span>Drop、Truncate、Delete 操作比较</span></a></h2><p>以下是 SQL 中 DROP、TRUNCATE 和 DELETE 操作的比较：</p><ul><li><p><strong>回滚支持</strong>：</p><ul><li>DELETE 支持回滚，而 DROP 和 TRUNCATE 不支持。</li></ul></li><li><p><strong>删除内容</strong>：</p><ul><li>DELETE：表结构仍然存在，可以删除表中的全部或部分数据。</li><li>TRUNCATE：表结构仍然存在，删除表中的全部数据。</li><li>DROP：删除表结构以及表中的全部数据。</li></ul></li></ul><h2 id="exist-与-in-的区别" tabindex="-1"><a class="header-anchor" href="#exist-与-in-的区别"><span>EXIST 与 IN 的区别</span></a></h2><p>EXIST 和 IN 是 SQL 中用于子查询的两种不同关键字，它们在功能和性能上有所差异。</p><h3 id="exist" tabindex="-1"><a class="header-anchor" href="#exist"><span>EXIST</span></a></h3><ul><li>EXIST 后面是一个子查询。</li><li>它只关注子查询是否返回数据，如果返回结果为 true，则继续执行前面的语句。</li><li>即使子查询返回 NULL，EXIST 也视为 true。</li><li>EXIST 对外表进行循环（loop），对每个记录检查子查询是否返回结果。</li></ul><h3 id="in" tabindex="-1"><a class="header-anchor" href="#in"><span>IN</span></a></h3><ul><li>IN 先执行子查询并获取结果集。</li><li>对结果集中的每个值进行循环比对主查询表中对应字段，汇总匹配值返回最终结果。</li><li>IN 内外表做哈希连接（hash join）。</li></ul><h3 id="性能考虑" tabindex="-1"><a class="header-anchor" href="#性能考虑"><span>性能考虑</span></a></h3><ul><li>当两个表的大小相当时，使用 EXIST 或 IN 的性能差不多。</li><li>当两个表一大一小，子查询大的表使用 EXIST，小的表使用 IN。</li></ul><h2 id="not-exists-与-not-in-的区别" tabindex="-1"><a class="header-anchor" href="#not-exists-与-not-in-的区别"><span>NOT EXISTS 与 NOT IN 的区别</span></a></h2><p>在 SQL 中，NOT EXISTS 和 NOT IN 都是用来检查子查询中是否存在记录的条件，但它们在性能和用法上有所不同。</p><h3 id="not-in" tabindex="-1"><a class="header-anchor" href="#not-in"><span>NOT IN</span></a></h3><ul><li>NOT IN 子句在子查询中进行全表扫描，无论内表还是外表。</li><li>这意味着 NOT IN 可能在性能上不是最优的，尤其是在处理大型数据集时。</li></ul><h3 id="not-exists" tabindex="-1"><a class="header-anchor" href="#not-exists"><span>NOT EXISTS</span></a></h3><ul><li>NOT EXISTS 通常比 NOT IN 更高效，因为它只检查子查询中是否存在记录，而不是检索所有记录。</li><li>NOT EXISTS 允许子查询利用索引，这可以显著提高查询性能。</li><li>在逻辑上，NOT EXISTS 等同于 EXISTS 的否定形式。</li></ul><h3 id="性能比较" tabindex="-1"><a class="header-anchor" href="#性能比较"><span>性能比较</span></a></h3><ul><li>当两个表的大小相当时，NOT EXISTS 通常比 NOT IN 更快，因为它可以利用索引。</li><li>当子查询的表比主查询的表大时，NOT EXISTS 仍然可能是更好的选择，因为它可以更早地终止查询。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span></span>
<span class="line"><span class="token keyword">FROM</span> customers c</span>
<span class="line"><span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>id <span class="token operator">IN</span> <span class="token punctuation">(</span></span>
<span class="line"><span class="token keyword">SELECT</span> customer_id</span>
<span class="line"><span class="token keyword">FROM</span> orders o</span>
<span class="line"><span class="token keyword">WHERE</span> o<span class="token punctuation">.</span>order_date <span class="token operator">=</span> <span class="token string">&#39;2024-01-01&#39;</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>o是内表</p></div><h2 id="sql-优化建议" tabindex="-1"><a class="header-anchor" href="#sql-优化建议"><span>SQL 优化建议</span></a></h2><p>为了提高数据库查询的性能，以下是一些有效的 SQL 优化策略：</p><ol><li>**避免使用 SELECT ***：</li></ol><ul><li>不使用 SELECT * 可以确保查询只返回需要的列，这样可以减少数据传输量，同时可能利用覆盖索引。</li></ul><ol start="2"><li><strong>谨慎使用 OR 操作符</strong>：</li></ol><ul><li>避免使用 OR，因为连接的两个条件可能使用不同的索引，导致数据库无法使用任何索引。可以考虑使用 UNION ALL 替代。</li></ul><ol start="3"><li><strong>使用数值代替字符串</strong>：</li></ol><ul><li>当属性值固定时，尽量使用数值类型代替字符串类型，以提高查询效率。</li></ul><ol start="4"><li><strong>限制返回的数据量</strong>：</li></ol><ul><li>避免返回大量数据，最好采用分页查询来减少单次查询的数据量。</li></ul><ol start="5"><li><strong>合理使用索引</strong>：</li></ol><ul><li>确保对经常作为查询条件的列建立索引，同时避免过度索引，以免影响数据更新性能。</li></ul><ol start="6"><li><strong>使用批量插入</strong>：</li></ol><ul><li>当需要插入大量数据时，使用批量插入代替单条插入，以提高插入效率。</li></ul><ol start="7"><li><strong>使用 UNION ALL 代替 UNION</strong>：</li></ol><ul><li>当合并两个查询结果集时，如果不需要去除重复记录，使用 UNION ALL 替代 UNION，因为 UNION ALL 不会进行去重操作，执行速度更快。</li></ul><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h2><p>事务是数据库管理系统中的一个核心概念，它确保了对数据库进行的一系列操作要么全部成功，要么在遇到错误时全部撤销，从而保证了数据的一致性。</p><h3 id="myisam" tabindex="-1"><a class="header-anchor" href="#myisam"><span>MYISAM</span></a></h3><ul><li>表锁级别</li><li>不支持事务和外键</li></ul><h3 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb"><span>InnoDB</span></a></h3><ul><li>行锁级别</li><li>支持事务和外键</li></ul><h3 id="memory" tabindex="-1"><a class="header-anchor" href="#memory"><span>Memory</span></a></h3><ul><li>内存操作，读写速度快</li><li>不支持事务和外键</li></ul><h2 id="sql-排查及优化指南" tabindex="-1"><a class="header-anchor" href="#sql-排查及优化指南"><span>SQL 排查及优化指南</span></a></h2><p>为了提高 SQL 查询的性能，可以按照以下步骤进行排查和优化：</p><h3 id="_1-开启慢查询日志" tabindex="-1"><a class="header-anchor" href="#_1-开启慢查询日志"><span>1. 开启慢查询日志</span></a></h3><ul><li>首先，需要在数据库配置中开启慢查询日志，以便记录执行时间超过指定阈值的查询。</li></ul><h3 id="_2-查看慢查询日志" tabindex="-1"><a class="header-anchor" href="#_2-查看慢查询日志"><span>2. 查看慢查询日志</span></a></h3><ul><li>分析慢查询日志，找出执行效率低的 SQL 语句。</li></ul><h3 id="_3-使用-explain-查看-sql-执行计划" tabindex="-1"><a class="header-anchor" href="#_3-使用-explain-查看-sql-执行计划"><span>3. 使用 EXPLAIN 查看 SQL 执行计划</span></a></h3><ul><li>使用 EXPLAIN 关键字分析 SQL 语句的执行计划，以了解查询的执行过程和性能瓶颈。</li></ul><h2 id="explain-的-type-字段性能排序" tabindex="-1"><a class="header-anchor" href="#explain-的-type-字段性能排序"><span>EXPLAIN 的 Type 字段性能排序</span></a></h2><p>在 EXPLAIN 的输出结果中，Type 字段表示连接类型，性能从最好到最差的排序如下：</p><ol><li>system：表只有一行（=0），这是 const 类型 join 的情况。</li><li>const：表最多有一个匹配行，速度非常快。</li><li>eq_ref：对于每个来自前一个表的行组合，从该表中读取一行。</li><li>ref：对于来自前一个表的每个行组合，从该表中读取多行。</li><li>index_merge：索引合并，速度比 ref 慢。</li><li>index：全索引扫描，比 index_merge 慢。</li><li>all：全表扫描，性能最差。</li></ol><h2 id="sql-执行顺序" tabindex="-1"><a class="header-anchor" href="#sql-执行顺序"><span>SQL 执行顺序</span></a></h2><p>在编写 SQL 查询时，了解各子句的执行顺序对于优化查询性能至关重要。以下是 SQL 查询的典型执行顺序：</p><ol><li><strong>FROM 和 JOIN</strong></li></ol><ul><li>首先确定数据来源，即从哪些表中获取数据，以及如何通过 JOIN 连接这些表。</li></ul><ol start="2"><li><strong>ON</strong></li></ol><ul><li>指定 JOIN 操作中用于连接表的条件。</li></ul><ol start="3"><li><strong>WHERE</strong></li></ol><ul><li>在获取表数据后，根据特定条件筛选数据。</li></ul><ol start="4"><li><strong>GROUP BY</strong></li></ol><ul><li>将筛选后的数据按照一个或多个列进行分组。</li></ul><ol start="5"><li><strong>聚合函数</strong></li></ol><ul><li>对每个分组执行聚合操作，如 COUNT、SUM、AVG 等。</li></ul><ol start="6"><li><strong>HAVING</strong></li></ol><ul><li>对分组后的结果进行进一步的筛选，通常用于筛选聚合后的结果。</li></ul><ol start="7"><li><strong>SELECT</strong></li></ol><ul><li>指定最终选择哪些列显示在结果集中，并进行行层面的结束处理。</li></ul><ol start="8"><li><strong>DISTINCT</strong></li></ol><ul><li>在列层面进行去重操作，确保结果集中的值是唯一的。</li></ul><ol start="9"><li><strong>ORDER BY</strong></li></ol><ul><li>最后，根据一个或多个列对结果集进行排序。</li></ul><h2 id="mysql-与-elasticsearch-数据一致性实现" tabindex="-1"><a class="header-anchor" href="#mysql-与-elasticsearch-数据一致性实现"><span>MySQL 与 Elasticsearch 数据一致性实现</span></a></h2><p>为了确保 MySQL 数据库与 Elasticsearch 搜索引擎之间的数据一致性，可以采用以下几种方法：</p><h3 id="同步调用-双写" tabindex="-1"><a class="header-anchor" href="#同步调用-双写"><span>同步调用（双写）</span></a></h3><ul><li><strong>实现方式</strong>：在修改 MySQL 数据的同时，同步写入 Elasticsearch。</li><li><strong>优点</strong>：数据一致性高，立即反映在 Elasticsearch 中。</li><li><strong>缺点</strong>：耦合度高，每次修改 MySQL 时都会有额外的维护成本。</li></ul><h3 id="异步通知-消息队列" tabindex="-1"><a class="header-anchor" href="#异步通知-消息队列"><span>异步通知（消息队列）</span></a></h3><ul><li><strong>实现方式</strong>：使用消息队列（如 Kafka、RabbitMQ）进行异步数据同步。数据变更时触发一个消息队列消息，消费端订阅这个消息并同步到 Elasticsearch。</li><li><strong>优点</strong>：解耦，系统之间独立，提高了系统的可扩展性。</li><li><strong>缺点</strong>：需要引入第三方组件，增加了系统的复杂度。</li></ul><h3 id="监听-binlog-日志监听" tabindex="-1"><a class="header-anchor" href="#监听-binlog-日志监听"><span>监听 Binlog（日志监听）</span></a></h3><ul><li><strong>实现方式</strong>：使用阿里 Canal 组件监听 MySQL 的 Binlog 日志，捕获数据变更事件，并实时推送到 Elasticsearch。</li><li><strong>优点</strong>：不需要接入到业务系统中，减少了系统的耦合度。</li><li><strong>缺点</strong>：需要处理 Binlog 日志的解析和数据同步的复杂性。</li></ul><h2 id="elasticsearch倒派索引" tabindex="-1"><a class="header-anchor" href="#elasticsearch倒派索引"><span>Elasticsearch倒派索引</span></a></h2><p>传统的我们的检索是逐个遍历找到对应关键词的位置，而倒排索引，是通过分词策略，</p><p>形成了词和id的映射关系表，通过这个表再通过id查文档，极大的提高了检索效率</p>`,126)]))}const h=n(s,[["render",t]]),d=JSON.parse('{"path":"/js/datebase.html","title":"date_base","lang":"zh-CN","frontmatter":{"title":"date_base","author":"chengp"},"headers":[{"level":2,"title":"并发数据库操作中的读取问题","slug":"并发数据库操作中的读取问题","link":"#并发数据库操作中的读取问题","children":[{"level":3,"title":"脏读 (Dirty Read)","slug":"脏读-dirty-read","link":"#脏读-dirty-read","children":[]},{"level":3,"title":"不可重复读 (Non-repeatable Read)","slug":"不可重复读-non-repeatable-read","link":"#不可重复读-non-repeatable-read","children":[]},{"level":3,"title":"幻读 (Phantom Read)","slug":"幻读-phantom-read","link":"#幻读-phantom-read","children":[]},{"level":3,"title":"隔离级别","slug":"隔离级别","link":"#隔离级别","children":[]}]},{"level":2,"title":"聚簇索引","slug":"聚簇索引","link":"#聚簇索引","children":[]},{"level":2,"title":"非聚簇索引（二级索引）","slug":"非聚簇索引-二级索引","link":"#非聚簇索引-二级索引","children":[]},{"level":2,"title":"索引覆盖（减少回表次数）","slug":"索引覆盖-减少回表次数","link":"#索引覆盖-减少回表次数","children":[]},{"level":2,"title":"MyISAM 与 InnoDB 存储引擎的区别","slug":"myisam-与-innodb-存储引擎的区别","link":"#myisam-与-innodb-存储引擎的区别","children":[{"level":3,"title":"事务支持","slug":"事务支持","link":"#事务支持","children":[]},{"level":3,"title":"锁定级别","slug":"锁定级别","link":"#锁定级别","children":[]},{"level":3,"title":"外键支持","slug":"外键支持","link":"#外键支持","children":[]},{"level":3,"title":"ACID 支持","slug":"acid-支持","link":"#acid-支持","children":[]},{"level":3,"title":"性能","slug":"性能","link":"#性能","children":[]}]},{"level":2,"title":"索引失效","slug":"索引失效","link":"#索引失效","children":[]},{"level":2,"title":"Drop、Truncate、Delete 操作比较","slug":"drop、truncate、delete-操作比较","link":"#drop、truncate、delete-操作比较","children":[]},{"level":2,"title":"EXIST 与 IN 的区别","slug":"exist-与-in-的区别","link":"#exist-与-in-的区别","children":[{"level":3,"title":"EXIST","slug":"exist","link":"#exist","children":[]},{"level":3,"title":"IN","slug":"in","link":"#in","children":[]},{"level":3,"title":"性能考虑","slug":"性能考虑","link":"#性能考虑","children":[]}]},{"level":2,"title":"NOT EXISTS 与 NOT IN 的区别","slug":"not-exists-与-not-in-的区别","link":"#not-exists-与-not-in-的区别","children":[{"level":3,"title":"NOT IN","slug":"not-in","link":"#not-in","children":[]},{"level":3,"title":"NOT EXISTS","slug":"not-exists","link":"#not-exists","children":[]},{"level":3,"title":"性能比较","slug":"性能比较","link":"#性能比较","children":[]}]},{"level":2,"title":"SQL 优化建议","slug":"sql-优化建议","link":"#sql-优化建议","children":[]},{"level":2,"title":"事务","slug":"事务","link":"#事务","children":[{"level":3,"title":"MYISAM","slug":"myisam","link":"#myisam","children":[]},{"level":3,"title":"InnoDB","slug":"innodb","link":"#innodb","children":[]},{"level":3,"title":"Memory","slug":"memory","link":"#memory","children":[]}]},{"level":2,"title":"SQL 排查及优化指南","slug":"sql-排查及优化指南","link":"#sql-排查及优化指南","children":[{"level":3,"title":"1. 开启慢查询日志","slug":"_1-开启慢查询日志","link":"#_1-开启慢查询日志","children":[]},{"level":3,"title":"2. 查看慢查询日志","slug":"_2-查看慢查询日志","link":"#_2-查看慢查询日志","children":[]},{"level":3,"title":"3. 使用 EXPLAIN 查看 SQL 执行计划","slug":"_3-使用-explain-查看-sql-执行计划","link":"#_3-使用-explain-查看-sql-执行计划","children":[]}]},{"level":2,"title":"EXPLAIN 的 Type 字段性能排序","slug":"explain-的-type-字段性能排序","link":"#explain-的-type-字段性能排序","children":[]},{"level":2,"title":"SQL 执行顺序","slug":"sql-执行顺序","link":"#sql-执行顺序","children":[]},{"level":2,"title":"MySQL 与 Elasticsearch 数据一致性实现","slug":"mysql-与-elasticsearch-数据一致性实现","link":"#mysql-与-elasticsearch-数据一致性实现","children":[{"level":3,"title":"同步调用（双写）","slug":"同步调用-双写","link":"#同步调用-双写","children":[]},{"level":3,"title":"异步通知（消息队列）","slug":"异步通知-消息队列","link":"#异步通知-消息队列","children":[]},{"level":3,"title":"监听 Binlog（日志监听）","slug":"监听-binlog-日志监听","link":"#监听-binlog-日志监听","children":[]}]},{"level":2,"title":"Elasticsearch倒派索引","slug":"elasticsearch倒派索引","link":"#elasticsearch倒派索引","children":[]}],"git":{"updatedTime":1748329949000,"contributors":[{"name":"“root”","username":"","email":"1787536379@qq.com","commits":3}],"changelog":[{"hash":"5060321abaa67e9154b1456a9d36705be88f8f8e","time":1748329949000,"email":"1787536379@qq.com","author":"“root”","message":"add 学习文档"},{"hash":"7de995f7b2d57b6ed805b307410fa1c43160096b","time":1748240439000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"},{"hash":"2f28edffd20e17e141c8d3f074c0c15dbcd3bc6c","time":1748231170000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"}]},"filePathRelative":"js/datebase.md","excerpt":"<h2>并发数据库操作中的读取问题</h2>\\n<p>在并发数据库操作中，可能会出现脏读、不可重复读和幻读等问题，这些问题都与事务的隔离级别有关。</p>\\n<h3>脏读 (Dirty Read)</h3>\\n<ul>\\n<li><strong>定义</strong>：一个事务读取到了另一个事务未提交的数据。</li>\\n<li><strong>影响</strong>：如果未提交的事务最终被回滚，那么读取到的数据就是无效的，这可能导致错误的决策。</li>\\n</ul>\\n<h3>不可重复读 (Non-repeatable Read)</h3>\\n<ul>\\n<li><strong>定义</strong>：在一个事务中多次读取同一数据，如果在两次读取之间，其他事务对数据进行了修改，那么两次读取的数据可能不一致。</li>\\n<li><strong>影响</strong>：这可能导致事务在处理过程中得到不同的结果，影响数据的一致性。</li>\\n</ul>"}');export{h as comp,d as data};

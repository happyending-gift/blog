import{_ as d,c as n,a as e,o as a}from"./app-C3OQ5REo.js";const r={};function l(o,t){return a(),n("div",null,t[0]||(t[0]=[e('<h2 id="三大消息队列区别" tabindex="-1"><a class="header-anchor" href="#三大消息队列区别"><span>三大消息队列区别</span></a></h2><p>以下是Kafka、RocketMQ 和 RabbitMQ 三种常见消息队列的对比：</p><table><thead><tr><th>特性</th><th>Kafka</th><th>RocketMQ</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>吞吐量</td><td>高</td><td>高</td><td>中等</td></tr><tr><td>死信队列</td><td>×</td><td>√</td><td>√</td></tr><tr><td>延迟队列</td><td>×</td><td>√</td><td>√</td></tr><tr><td>优先级队列</td><td>×</td><td>√</td><td>√</td></tr><tr><td>消息获取</td><td>拉</td><td>推/拉</td><td>推/拉</td></tr><tr><td>支持事务</td><td>仅消息生产事务</td><td>支持</td><td>支持</td></tr></tbody></table><h2 id="mq-消息丢失问题及解决方案" tabindex="-1"><a class="header-anchor" href="#mq-消息丢失问题及解决方案"><span>MQ 消息丢失问题及解决方案</span></a></h2><p>在消息队列（MQ）的使用过程中，消息丢失是一个需要特别注意的问题。以下是消息在不同阶段可能丢失的原因以及相应的解决方案：</p><h3 id="信息到-mq" tabindex="-1"><a class="header-anchor" href="#信息到-mq"><span>信息到 MQ</span></a></h3><p>在这个阶段，消息从生产者发送到消息队列的过程中可能会丢失。</p><p>解决方案：</p><ul><li><strong>发送方确认模式</strong>：确保消息被成功发送到消息队列。例如，在 RabbitMQ 中，可以通过设置 <code>mandatory</code> 标志来实现。如果消息无法被路由到任何队列，RabbitMQ 会发送一个 <code>return</code> 消息到指定的交换机。</li><li><strong>事务支持</strong>：使用事务来确保消息的发送和确认。例如，在 Kafka 中，可以通过 <code>acks</code> 参数来控制消息的确认机制。</li></ul><h3 id="信息路由到队列" tabindex="-1"><a class="header-anchor" href="#信息路由到队列"><span>信息路由到队列</span></a></h3><p>在这个阶段，消息在被路由到特定队列的过程中可能会丢失。</p><p>解决方案：</p><ul><li><strong>路由失败通知</strong>：在 RabbitMQ 中，可以在配置新的 <code>RabbitTemplate</code> 时开启路由失败通知。这样，如果消息无法被路由到任何队列，将会触发一个回调函数。</li><li><strong>监控和报警</strong>：设置监控和报警机制，以便在路由失败时及时得到通知。</li></ul><h3 id="消息在队列正确存储" tabindex="-1"><a class="header-anchor" href="#消息在队列正确存储"><span>消息在队列正确存储</span></a></h3><p>在这个阶段，消息已经到达队列，但在存储过程中可能会丢失。</p><p>解决方案：</p><ul><li><strong>持久化配置</strong>：确保交换机、队列和消息都被设置为持久化。例如，在 RabbitMQ 中，可以通过设置 <code>durable</code> 属性来实现队列的持久化，以及通过 <code>deliveryMode</code> 来设置消息的持久化。</li><li><strong>备份和复制</strong>：使用队列的备份和复制机制来提高数据的可靠性。</li></ul><h3 id="队列投递到消费者" tabindex="-1"><a class="header-anchor" href="#队列投递到消费者"><span>队列投递到消费者</span></a></h3><p>在这个阶段，消息从队列投递到消费者的过程中可能会丢失。</p><p>解决方案：</p><ul><li><strong>消费者确认</strong>：确保消费者在处理完消息后进行确认。例如，在 RabbitMQ 中，可以通过设置手动提交（<code>manual</code> 或 <code>manualAckNow</code>）来实现。</li><li><strong>监听容器</strong>：使用监听容器来异步接收消息，并在确认消息后进行处理。</li><li><strong>绑定队列</strong>：正确绑定队列和消费者，确保消息能够被正确投递。</li><li><strong>定义消费者确认方法</strong>：在消费者中定义确认方法，确保在消息处理成功后进行确认。</li></ul>',21)]))}const s=d(r,[["render",l]]),h=JSON.parse('{"path":"/js/mq1.html","title":"mq","lang":"zh-CN","frontmatter":{"title":"mq","author":"chengp"},"headers":[{"level":2,"title":"三大消息队列区别","slug":"三大消息队列区别","link":"#三大消息队列区别","children":[]},{"level":2,"title":"MQ 消息丢失问题及解决方案","slug":"mq-消息丢失问题及解决方案","link":"#mq-消息丢失问题及解决方案","children":[{"level":3,"title":"信息到 MQ","slug":"信息到-mq","link":"#信息到-mq","children":[]},{"level":3,"title":"信息路由到队列","slug":"信息路由到队列","link":"#信息路由到队列","children":[]},{"level":3,"title":"消息在队列正确存储","slug":"消息在队列正确存储","link":"#消息在队列正确存储","children":[]},{"level":3,"title":"队列投递到消费者","slug":"队列投递到消费者","link":"#队列投递到消费者","children":[]}]}],"git":{"updatedTime":1748240439000,"contributors":[{"name":"“root”","username":"","email":"1787536379@qq.com","commits":2}],"changelog":[{"hash":"7de995f7b2d57b6ed805b307410fa1c43160096b","time":1748240439000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"},{"hash":"2f28edffd20e17e141c8d3f074c0c15dbcd3bc6c","time":1748231170000,"email":"1787536379@qq.com","author":"“root”","message":"content 2.0"}]},"filePathRelative":"js/mq1.md","excerpt":"<h2>三大消息队列区别</h2>\\n<p>以下是Kafka、RocketMQ 和 RabbitMQ 三种常见消息队列的对比：</p>\\n<table>\\n<thead>\\n<tr>\\n<th>特性</th>\\n<th>Kafka</th>\\n<th>RocketMQ</th>\\n<th>RabbitMQ</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>吞吐量</td>\\n<td>高</td>\\n<td>高</td>\\n<td>中等</td>\\n</tr>\\n<tr>\\n<td>死信队列</td>\\n<td>×</td>\\n<td>√</td>\\n<td>√</td>\\n</tr>\\n<tr>\\n<td>延迟队列</td>\\n<td>×</td>\\n<td>√</td>\\n<td>√</td>\\n</tr>\\n<tr>\\n<td>优先级队列</td>\\n<td>×</td>\\n<td>√</td>\\n<td>√</td>\\n</tr>\\n<tr>\\n<td>消息获取</td>\\n<td>拉</td>\\n<td>推/拉</td>\\n<td>推/拉</td>\\n</tr>\\n<tr>\\n<td>支持事务</td>\\n<td>仅消息生产事务</td>\\n<td>支持</td>\\n<td>支持</td>\\n</tr>\\n</tbody>\\n</table>"}');export{s as comp,h as data};
